# 学生管理系统

##  登录窗口

```java
package view;

import javax.swing.*;

import controller.BindView;
import controller.StudentController;
import controller.UserController;

import java.awt.event.*;
import java.util.List;

public class Login extends JFrame implements ActionListener {
	private JButton studentLoginButton, teacherLoginButton, cancelButton, adminLoginButton;
	private JTextField uidField;
	private JPasswordField pwdField;
	UserController userController = new UserController(null);// 验证登录是否成功

	public Login() {
		// 设置窗口基本属性
		this.setSize(350, 250);
		this.setTitle("登录系统");
		this.setDefaultCloseOperation(EXIT_ON_CLOSE);
		this.setLayout(null);
		this.setLocationRelativeTo(null);

		// 初始化组件
		initComponents();
	}

	private void initComponents() {
		// 学生登录按钮
		studentLoginButton = new JButton("学生登录");
		studentLoginButton.setBounds(10, 120, 100, 30);
		studentLoginButton.addActionListener(this);
		this.add(studentLoginButton);

		// 老师登录按钮
		teacherLoginButton = new JButton("老师登录");
		teacherLoginButton.setBounds(100, 120, 100, 30);
		teacherLoginButton.addActionListener(this);
		this.add(teacherLoginButton);

		// 管理员登录按钮
		adminLoginButton = new JButton("管理登录");
		adminLoginButton.setBounds(200, 120, 100, 30);
		adminLoginButton.addActionListener(this);
		this.add(adminLoginButton);

		// 取消按钮
		cancelButton = new JButton("重置");
		cancelButton.setBounds(100, 160, 100, 30);
		cancelButton.addActionListener(this);
		this.add(cancelButton);

		// 用户名输入框
		uidField = new JTextField();
		uidField.setBounds(100, 40, 120, 30);
		this.add(uidField);

		// 密码输入框
		pwdField = new JPasswordField();
		pwdField.setBounds(100, 80, 120, 30);
		this.add(pwdField);

		// 标签
		JLabel uidLabel = new JLabel("用户名：");
		uidLabel.setBounds(30, 40, 60, 30);
		this.add(uidLabel);

		JLabel pwdLabel = new JLabel("密码：");
		pwdLabel.setBounds(30, 80, 60, 30);
		this.add(pwdLabel);
	}

	@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == studentLoginButton) {
			login(0);
		} else if (e.getSource() == teacherLoginButton) {
			login(1);
		} else if (e.getSource() == adminLoginButton) {
			login(2);
		} else if (e.getSource() == cancelButton) {
			// 清空输入框
			uidField.setText("");
			pwdField.setText("");
		}
	}

	private void login(int role) {
		String username = uidField.getText();
		String password = new String(pwdField.getPassword());
		String sql_role = String.valueOf(role);

		BindView View = new BindView();
		if (role == 0 && userController.studentLogin(username, password)) {
			View.bind(0,username,password);
		} else if (role == 1 && userController.login(username, password, sql_role)) {
			View.bind(1,"I am a teacher","000000");
		} else if (role == 2 && userController.login(username, password, sql_role)) {
			View.bind(2,"I am a admin","000000");
		} else {
			JOptionPane.showMessageDialog(this, "密码错误！");
		}

	}
}
```

这个代码类是一个 **登录界面**（`Login` 类），主要用于处理用户登录的操作，包括学生、老师和管理员的登录。

### 类：`Login`

#### 1. **功能概述：**

- 提供一个登录界面，用户可以选择登录角色（学生、老师、管理员）。
- 输入用户名和密码进行验证。
- 根据不同的角色（学生、老师、管理员）跳转到对应的视图。

#### 2. **构造方法：**

- `Login()`：初始化窗口的基本属性（大小、标题、关闭操作等），并调用 `initComponents()` 方法初始化界面组件。

#### 3. **成员变量：**

- `studentLoginButton`, `teacherLoginButton`, `adminLoginButton`：分别用于学生、老师和管理员的登录按钮。
- `cancelButton`：用于重置输入框的按钮。
- `uidField`：用于输入用户名的文本框。
- `pwdField`：用于输入密码的密码框。
- `userController`：控制器类，负责验证登录信息。

#### 4. **`initComponents()` 方法：**

- 初始化所有界面组件（按钮、文本框、标签等），并设置它们的位置和事件监听器。

#### 5. **事件处理：**

- 实现了 `ActionListener` 接口，重写了 `actionPerformed()` 方法，根据点击的按钮执行相应的登录逻辑。

  - 学生、老师、管理员登录按钮分别调用 `login()` 方法进行身份验证。
  - 重置按钮清空输入框。

#### 6. **`login()` 方法：**

- 根据用户选择的角色（学生、老师、管理员）验证输入的用户名和密码。
- 调用 `userController` 类的 `studentLogin()` 或 `login()` 方法验证登录。
- 根据验证结果，调用 `BindView` 类的 `bind()` 方法跳转到不同的视图。
- 如果登录失败，弹出错误提示框。

#### 7. **用户角色：**

- `role == 0`：学生登录，调用 `userController.studentLogin()` 方法。
- `role == 1`：老师登录，调用 `userController.login()` 方法。
- `role == 2`：管理员登录，调用 `userController.login()` 方法。
- 如果登录验证失败，弹出提示框，显示 "密码错误！"。

#### 8. **未开发功能：**

- 当前代码中对于学生视图、老师视图、管理员视图的跳转逻辑都被注释掉了，实际应用中需要根据不同角色跳转到对应的界面。

#### 9. **扩展建议：**

- 可以在 `BindView` 类的 `bind()` 方法中进行更详细的视图切换和界面初始化。
- 可以考虑增加更多的登录失败提示，如用户名错误等。

### 总结：

`Login` 类是整个学生管理系统的入口界面，负责处理用户登录逻辑，并根据用户角色跳转到不同的视图。通过 `JTextField` 和 `JPasswordField` 获取用户输入，通过 `JButton` 触发事件进行角色区分登录验证。需要注意的是，视图切换部分目前尚未开发完整。

------







## `AddPanel` 类

```java
package view;

import javax.swing.*;

import controller.StudentController;
import controller.UserController;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.SimpleDateFormat;
import java.util.Date;

// 新增面板类，构建用于输入新增学生信息的面板以及相关操作逻辑
public class AddPanel {

	private JPanel panel;
	private JTextField addUserNameField, addNameField, addPhoneField, addAddressField, addPasswordField;
	private JRadioButton maleRadioButton, femaleRadioButton, teacherRadioButton, adminRadioButton;
	private JSpinner birthDateSpinner;
	private JButton addButton;
	private StudentManagerView parentView;

	public AddPanel(StudentManagerView parentView, int role) {
		this.parentView = parentView;
		initialize(role);
	}

	private void initialize(int role) {
		if (role == 1) {
			createStudentForm();
		} else if (role == 2) {
			createUserForm();
		}
	}

	private void createStudentForm() {
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		// 学生姓名输入框
		addNameField = createTextFieldPanel(panel, "新增学生姓名：");

		// 性别单选框
		maleRadioButton = new JRadioButton("男");
		femaleRadioButton = new JRadioButton("女");
		ButtonGroup genderGroup = new ButtonGroup();
		genderGroup.add(maleRadioButton);
		genderGroup.add(femaleRadioButton);
		panel.add(createPanelWithLabel("性别：", maleRadioButton, femaleRadioButton));

		// 出生日期选择器
		birthDateSpinner = new JSpinner(new SpinnerDateModel());
		JSpinner.DateEditor dateEditor = new JSpinner.DateEditor(birthDateSpinner, "yyyy-MM-dd");
		birthDateSpinner.setEditor(dateEditor);
		panel.add(createPanelWithLabel("出生日期：", birthDateSpinner));

		// 电话输入框
		addPhoneField = createTextFieldPanel(panel, "电话：");

		// 地址输入框
		addAddressField = createTextFieldPanel(panel, "地址：");
		// 密码输入框
		addPasswordField = createTextFieldPanel(panel, "密码：");

		// 提交按钮
		addButton = new JButton("提交");
		addButton.setPreferredSize(new Dimension(150, 40));
		panel.add(addButton);

		addButton.addActionListener(e -> handleAddButtonClick());
	}

	private void createUserForm() {
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		// 用户真实姓名输入框
		addUserNameField = createTextFieldPanel(panel, "新增用户真实姓名：");
		// 用户姓名输入框
		addNameField = createTextFieldPanel(panel, "新增用户账号：");

		// 角色单选框
		teacherRadioButton = new JRadioButton("老师");
		adminRadioButton = new JRadioButton("管理员");
		ButtonGroup roleGroup = new ButtonGroup();
		roleGroup.add(teacherRadioButton);
		roleGroup.add(adminRadioButton);
		panel.add(createPanelWithLabel("角色：", teacherRadioButton, adminRadioButton));

		// 密码输入框
		addPasswordField = createTextFieldPanel(panel, "密码：");

		// 提交按钮
		addButton = new JButton("提交");
		addButton.setPreferredSize(new Dimension(150, 40));
		panel.add(addButton);

		addButton.addActionListener(e -> handleUserAddButtonClick());
	}

	private JTextField createTextFieldPanel(JPanel panel, String label) {
		JPanel subPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		subPanel.add(new JLabel(label));
		JTextField textField = new JTextField(20);
		subPanel.add(textField);
		panel.add(subPanel);
		return textField;
	}

	private JPanel createPanelWithLabel(String label, JComponent... components) {
		JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		panel.add(new JLabel(label));
		for (JComponent comp : components) {
			panel.add(comp);
		}
		return panel;
	}

	private void handleAddButtonClick() {

		System.out.print("点击了新增学生信息");
		String name = addNameField.getText();
		String gender = maleRadioButton.isSelected() ? "男" : "女";
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		Date birthDate = (Date) birthDateSpinner.getValue();
		String formattedBirthDate = sdf.format(birthDate);
		String phone = addPhoneField.getText();
		String address = addAddressField.getText();
		String password = addPasswordField.getText();
		// 调试信息
		System.out.println("点击了新增学生信息");
		System.out.println("学生姓名: " + name);
		System.out.println("性别: " + gender);
		System.out.println("出生日期: " + formattedBirthDate);
		System.out.println("电话: " + phone);
		System.out.println("地址: " + address);
		System.out.println("密码: " + password);
		StudentController controller = new StudentController(this.parentView);
		controller.addStudent(null, name, gender, formattedBirthDate, phone, address, password);

		// 通过父视图调用控制器方法来添加学生信息
		parentView.updateStudentTable();
		clearAddForm();
	}

	private void clearAddForm() {
		addNameField.setText("");
		maleRadioButton.setSelected(true);
		birthDateSpinner.setValue(new Date());
		addPhoneField.setText("");
		addAddressField.setText("");
		addPasswordField.setText("");
	}

	private void clearUserAddForm() {
		addUserNameField.setText("");
		teacherRadioButton.setSelected(true);
		addNameField.setText("");
		addPasswordField.setText("");
	}

	// 新增学生表单
	private void addStudentForm(JPanel addPanel) {
		addPanel.setLayout(new BoxLayout(addPanel, BoxLayout.Y_AXIS));

		// 学生姓名输入框
		addNameField = createTextFieldPanel(addPanel, "新增学生姓名：");

		// 性别单选框
		maleRadioButton = new JRadioButton("男");
		femaleRadioButton = new JRadioButton("女");
		ButtonGroup genderGroup = new ButtonGroup();
		genderGroup.add(maleRadioButton);
		genderGroup.add(femaleRadioButton);
		addPanel.add(createPanelWithLabel("性别：", maleRadioButton, femaleRadioButton));

		// 出生日期选择器
		birthDateSpinner = new JSpinner(new SpinnerDateModel());
		JSpinner.DateEditor dateEditor = new JSpinner.DateEditor(birthDateSpinner, "yyyy-MM-dd");
		birthDateSpinner.setEditor(dateEditor);
		addPanel.add(createPanelWithLabel("出生日期：", birthDateSpinner));

		// 电话输入框
		addPhoneField = createTextFieldPanel(addPanel, "电话：");

		// 地址输入框
		addAddressField = createTextFieldPanel(addPanel, "地址：");
		// 地址输入框
		addPasswordField = createTextFieldPanel(addPanel, "密码：");

		// 提交按钮
		addButton = new JButton("提交");
		addButton.setPreferredSize(new Dimension(150, 40));
		addPanel.add(addButton);

		addButton.addActionListener(e -> handleAddButtonClick());
	}

	private void handleUserAddButtonClick() {

		System.out.print("点击了新增用户信息");
		String userName = addUserNameField.getText();
		String name = addNameField.getText();
		String role = teacherRadioButton.isSelected() ? "1" : "2";
		String password = addPasswordField.getText();
		// 调试信息
		System.out.println("点击了新增用户信息");
		System.out.println("用户姓名: " + name);
		System.out.println("性别: " + role);
		System.out.println("密码: " + password);
		UserController controller = new UserController(this.parentView);
		controller.addUser(null, userName, name, role, password);

		// 通过父视图调用控制器方法来添加学生信息
		parentView.updateUserTable();
		clearUserAddForm();
	}

	// 新增用户表单
	private void addUserForm(JPanel addPanel) {
		addPanel.setLayout(new BoxLayout(addPanel, BoxLayout.Y_AXIS));
		// 用户姓名输入框
		addUserNameField = createTextFieldPanel(addPanel, "新增用户真实姓名：");
		// 用户姓名输入框
		addNameField = createTextFieldPanel(addPanel, "新增用户姓名：");

		// 性别单选框
		maleRadioButton = new JRadioButton("男");
		femaleRadioButton = new JRadioButton("女");
		ButtonGroup genderGroup = new ButtonGroup();
		genderGroup.add(maleRadioButton);
		genderGroup.add(femaleRadioButton);
		addPanel.add(createPanelWithLabel("性别：", maleRadioButton, femaleRadioButton));
		// 角色单选框
		teacherRadioButton = new JRadioButton("老师");
		adminRadioButton = new JRadioButton("管理员");
		ButtonGroup roleGroup = new ButtonGroup();
		roleGroup.add(teacherRadioButton);
		roleGroup.add(adminRadioButton);
		addPanel.add(createPanelWithLabel("角色：", teacherRadioButton, adminRadioButton));
		// 出生日期选择器
		birthDateSpinner = new JSpinner(new SpinnerDateModel());
		JSpinner.DateEditor dateEditor = new JSpinner.DateEditor(birthDateSpinner, "yyyy-MM-dd");
		birthDateSpinner.setEditor(dateEditor);
		addPanel.add(createPanelWithLabel("出生日期：", birthDateSpinner));

		// 电话输入框
		addPhoneField = createTextFieldPanel(addPanel, "电话：");

		// 地址输入框
		addAddressField = createTextFieldPanel(addPanel, "地址：");
		// 地址输入框
		addPasswordField = createTextFieldPanel(addPanel, "密码：");

		// 提交按钮
		addButton = new JButton("提交");
		addButton.setPreferredSize(new Dimension(150, 40));
		addPanel.add(addButton);

		addButton.addActionListener(e -> handleUserAddButtonClick());
	}

	public JPanel getPanel() {
		return panel;
	}
}
```

这个代码类是一个 **学生信息和用户信息新增面板**（`AddPanel` 类），用于实现新增学生和用户的界面与操作逻辑。根据角色（学生管理或用户管理），该类动态创建不同的表单。以下是该类的总结：

### 类：`AddPanel`

#### 1. **功能概述：**

- 提供一个新增学生信息或用户信息的表单，支持输入姓名、性别、出生日期、电话、地址、密码等字段。
- 根据用户角色（学生或管理员）动态展示不同的表单。
- 提供提交按钮，提交数据到相应的控制器（`StudentController` 或 `UserController`）进行处理，并更新父视图中的学生或用户表格。

#### 2. **构造方法：**

- `AddPanel(StudentManagerView parentView, int role)`：根据传入的角色（学生或管理员）初始化不同的表单，并绑定父视图。

#### 3. **成员变量：**

- `panel`：面板容器，用于显示表单。
- 各种表单组件：
  - `addUserNameField`, `addNameField`, `addPhoneField`, `addAddressField`, `addPasswordField`：用于输入学生或用户的基本信息。
  - `maleRadioButton`, `femaleRadioButton`：用于选择性别。
  - `teacherRadioButton`, `adminRadioButton`：用于选择角色（教师或管理员）。
  - `birthDateSpinner`：用于选择出生日期。
  - `addButton`：提交按钮。
- `parentView`：父视图，通常是一个学生管理界面，用于更新学生或用户表格。

#### 4. **初始化方法：**

- `initialize(int role)`：根据角色类型（学生或用户管理）决定创建哪种表单：
  - `createStudentForm()`：创建学生表单。
  - `createUserForm()`：创建用户表单。

#### 5. **创建表单组件：**

- `createStudentForm()`：构建学生信息表单，包括姓名、性别、出生日期、电话、地址和密码输入框，以及提交按钮。
- `createUserForm()`：构建用户信息表单，包括用户姓名、账号、角色（教师/管理员）选择、密码输入框，以及提交按钮。

#### 6. **辅助方法：**

- `createTextFieldPanel()`：创建带标签的文本输入框。
- `createPanelWithLabel()`：创建带标签的面板，可以包含多个组件。

#### 7. **按钮点击处理：**

- `handleAddButtonClick()`：处理学生信息表单的提交，收集表单数据，调用 `StudentController.addStudent()` 方法将学生信息添加到数据库，并更新父视图的学生表格。
- `handleUserAddButtonClick()`：处理用户信息表单的提交，收集表单数据，调用 `UserController.addUser()` 方法将用户信息添加到数据库，并更新父视图的用户表格。

#### 8. **表单清空：**

- `clearAddForm()`：清空学生信息表单。
- `clearUserAddForm()`：清空用户信息表单。

#### 9. **表单重用：**

- `addStudentForm()` 和 `addUserForm()` 方法通过不同的布局和输入项，分别创建学生和用户的表单。

#### 10. **表单面板获取：**

- `getPanel()`：返回当前的面板，供外部视图或窗口显示。

### 总结：

`AddPanel` 类是一个动态表单创建类，能够根据角色（学生或用户）显示不同的表单。它通过与控制器（`StudentController` 和 `UserController`）的交互，将用户输入的数据提交到后端，并更新父视图中的表格数据。通过重用表单组件，代码保持了高效的结构，且易于维护。

------

建议：这个类的总结可以用来在`PPT`中展示该部分的实现逻辑，特别是如何动态创建表单、如何与控制器交互以及如何处理提交数据。





## QueryPanel类

```java
package view;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;

import controller.CourseController;
import controller.StudentController;
import controller.UserController;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

// 查询面板类，构建展示学生信息表格以及相关编辑功能的面板
public class QueryPanel {

	private JPanel panel;
	private JTable allStudentTable, allCourseTable, allUserTable;
	private JTextField 	editStudentIdField, 
						editSourceField,
						editNameField, 
						editRealNameField, 
						dobField, 
						editPhoneField, 
						editAddressField,
						editPasswordField;
	private JComboBox<String> genderComboBox, roleComboBox;
	private JButton submitButton, deleteButton, editPasswordButton;
	private int deleteID = -1, deleteRow = -1, deleteUserRow = -1, deleteUserID = -1;
	private StudentManagerView parentView;
	public int tableStudentId,tableCourseId;
	public String editStudentName,editStudentPassword;
	public QueryPanel(StudentManagerView parentView, int role, String name, String password) {
		this.parentView = parentView;
		initialize(role, name, password);
	}

	private void initialize(int role, String name, String password) {
		this.editStudentName = name;
		this.editStudentPassword = password;
		panel = new JPanel(new BorderLayout());
		allStudentTable = new JTable();
		allCourseTable = new JTable();// 渲染课程表
		allUserTable = new JTable();// 渲染用户表
		allStudentTable.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				System.out.print("我是老师\n");
				if (role == 1) {
					// 当用户点击表格行时，填充信息到修改表单
					System.out.print("我是老师\n");
					int selectedRow = allStudentTable.getSelectedRow();
					System.out.print("selectedRow: " + selectedRow + "\n");
					editStudentIdField.setText(allStudentTable.getValueAt(selectedRow, 0).toString());
					editNameField.setText(allStudentTable.getValueAt(selectedRow, 1).toString());
					genderComboBox.setSelectedItem(allStudentTable.getValueAt(selectedRow, 2).toString());
					dobField.setText(allStudentTable.getValueAt(selectedRow, 3).toString());
					editPhoneField.setText(allStudentTable.getValueAt(selectedRow, 4).toString());
					editAddressField.setText(allStudentTable.getValueAt(selectedRow, 5).toString());
					editPasswordField.setText(allStudentTable.getValueAt(selectedRow, 6).toString());
					// 获取要删除的学生的id
					String studentIdStr = allStudentTable.getValueAt(selectedRow, 0).toString();
					deleteRow = selectedRow;
					deleteID = Integer.parseInt(studentIdStr);
					System.out.print("deleteID  " + deleteID + "\n");
				}

			}
		});
		allUserTable.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				// 当管理员点击表格行时，填充信息到修改表单
				System.out.print("我是管理员\n");
				int selectedRow = allUserTable.getSelectedRow();
				System.out.print("selectedRow: " + selectedRow + "\n");
				if (selectedRow != -1) {
					editStudentIdField.setText(allUserTable.getValueAt(selectedRow, 0).toString());
					editRealNameField.setText(allUserTable.getValueAt(selectedRow, 1).toString());
					editNameField.setText(allUserTable.getValueAt(selectedRow, 2).toString());
					roleComboBox.setSelectedItem(allUserTable.getValueAt(selectedRow, 4).toString());
					editPasswordField.setText(allUserTable.getValueAt(selectedRow, 3).toString());
					// 获取要删除的学生的id
					String userIdStr = allUserTable.getValueAt(selectedRow, 0).toString();
					deleteUserRow = selectedRow;
					deleteUserID = Integer.parseInt(userIdStr);
					System.out.print("deleteUserID  " + deleteUserID + "\n");
				}
			}
		});
		allCourseTable.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				// 当学生点击表格行时，填充信息到修改表单
				System.out.print("我是学生的课程表\n");
				int selectedRow = allCourseTable.getSelectedRow();
				System.out.print("selectedRow: " + selectedRow + "\n");
				System.out.print("selectedId: " + allCourseTable.getValueAt(selectedRow, 0).toString() + "\n");
				if (selectedRow != -1) {
					//editStudentIdField.setText(allCourseTable.getValueAt(selectedRow, 0).toString());
					//editRealNameField.setText(allCourseTable.getValueAt(selectedRow, 1).toString());
					//editNameField.setText(allCourseTable.getValueAt(selectedRow, 2).toString());
					String studentId = editStudentIdField.getText();
					CourseController courseController = new CourseController(null);
					double source = courseController.showCurseSource(Integer.parseInt(studentId), Integer.parseInt(allCourseTable.getValueAt(selectedRow, 0).toString()));
					editSourceField.setText(String.valueOf(source));
					//生日框爆改课程名称框
					dobField.setText(allCourseTable.getValueAt(selectedRow, 1).toString());
					//地址框爆改任课老师
					editAddressField.setText(allCourseTable.getValueAt(selectedRow, 3).toString());
					//电话框爆改课程代码
					editPhoneField.setText(allCourseTable.getValueAt(selectedRow, 2).toString());
					System.out.print("选择的: " + allCourseTable.getValueAt(selectedRow, 0).toString() + "\n");
					System.out.print("选择的: " + allCourseTable.getValueAt(selectedRow, 1).toString() + "\n");
					System.out.print("选择的: " + allCourseTable.getValueAt(selectedRow, 2).toString() + "\n");
					System.out.print("选择的: " + allCourseTable.getValueAt(selectedRow, 3).toString() + "\n");
					// 获取要删除的学生的id
					String userIdStr = allCourseTable.getValueAt(selectedRow, 0).toString();
					deleteUserRow = selectedRow;
					deleteUserID = Integer.parseInt(userIdStr);
					System.out.print("deleteUserID  " + deleteUserID + "\n");
				}
			}
		});
		if (role == 0) {
			panel.add(new JScrollPane(allCourseTable), BorderLayout.CENTER);// 显示课程表
			// 为了给学生视图渲染信息
			StudentController studentController = new StudentController(null);
			List<String[]> studentInfo = studentController.getStudentByNameAndPassword(name, password);
			List<String[]> courceInfo = studentController.getStudentByNameAndPassword(name, password);
			
			System.out.println("查询的学生信息：");
			System.out.println(studentInfo.get(0)[0]);
			System.out.println(studentInfo.get(0)[1]);
			System.out.println(studentInfo.get(0)[2]);
			System.out.println(studentInfo.get(0)[3]);
			System.out.println(studentInfo.get(0)[4]);
			//this.tableStudentId = Integer.parseInt(studentInfo.get(0)[0]);
			
			JPanel editPanel = createSearchPanel(
					studentInfo.get(0)[0],
					this.editStudentName, 
					this.editStudentPassword, 
					"95.2",
					studentInfo.get(0)[2], 
					studentInfo.get(0)[3], 
					studentInfo.get(0)[4]	);
			panel.add(editPanel, BorderLayout.SOUTH);
		} else if (role == 1) {
			panel.add(new JScrollPane(allStudentTable), BorderLayout.CENTER);

			JPanel editPanel = createEditPanel();
			panel.add(editPanel, BorderLayout.SOUTH);
		} else if (role == 2) {
			panel.add(new JScrollPane(allUserTable), BorderLayout.CENTER);

			JPanel userEditPanel = createUserEditPanel();
			panel.add(userEditPanel, BorderLayout.SOUTH);
		}

	}

	private JPanel createEditPanel() {
		JPanel editPanel = new JPanel(new GridLayout(4, 2, 5, 5));

		// 添加编辑框
		editPanel.add(new JLabel("学生ID:"));
		editStudentIdField = new JTextField();
		editStudentIdField.setEditable(false);
		editPanel.add(editStudentIdField);

		editPanel.add(new JLabel("姓名:"));
		editNameField = new JTextField();
		editPanel.add(editNameField);

		editPanel.add(new JLabel("性别:"));
		genderComboBox = new JComboBox<>(new String[] { "男", "女" });
		editPanel.add(genderComboBox);

		editPanel.add(new JLabel("出生日期:"));
		dobField = new JTextField();
		dobField.setEditable(false);
		editPanel.add(dobField);

		editPanel.add(new JLabel("电话:"));
		editPhoneField = new JTextField();
		editPanel.add(editPhoneField);

		editPanel.add(new JLabel("地址:"));
		editAddressField = new JTextField();
		editPanel.add(editAddressField);

		editPanel.add(new JLabel("密码:"));
		editPasswordField = new JTextField();
		editPanel.add(editPasswordField);

		// 提交和删除按钮
		submitButton = new JButton("提交修改");
		deleteButton = new JButton("删除信息");
		editPanel.add(submitButton);
		editPanel.add(deleteButton);
		// 【删除按钮】监听器
		deleteButton.addActionListener(e -> handleDeleteButtonClick(1));

		// 【修改按钮】监听器
		submitButton.addActionListener(e -> handleUpdateButtonClick(1));

		return editPanel;

	}

	private JPanel createUserEditPanel() {
		JPanel editPanel = new JPanel(new GridLayout(2, 2, 5, 5));

		// 添加编辑框
		editPanel.add(new JLabel("用户ID:"));
		editStudentIdField = new JTextField();
		editStudentIdField.setEditable(false);
		editPanel.add(editStudentIdField);
		// 添加实名编辑框
		editPanel.add(new JLabel("姓名:"));
		editRealNameField = new JTextField();
		editPanel.add(editRealNameField);

		// 添加账号编辑框
		editPanel.add(new JLabel("账号:"));
		editNameField = new JTextField();
		editPanel.add(editNameField);

		editPanel.add(new JLabel("角色:"));
		roleComboBox = new JComboBox<>(new String[] { "老师", "管理员" });
		editPanel.add(roleComboBox);

		editPanel.add(new JLabel("密码:"));
		editPasswordField = new JTextField();
		editPanel.add(editPasswordField);

		// 提交和删除按钮
		submitButton = new JButton("提交修改");
		deleteButton = new JButton("删除信息");
		editPanel.add(submitButton);
		editPanel.add(deleteButton);
		// 【删除按钮】监听器
		deleteButton.addActionListener(e -> handleDeleteButtonClick(2));

		// 【修改按钮】监听器
		submitButton.addActionListener(e -> handleUpdateButtonClick(2));

		return editPanel;

	}

	// 创建查询面板

	// 添加查询按钮
	private JPanel createSearchPanel(
			String id, 
			String name, 
			String password, 
			String gender, 
			String brith, 
			String phone,
			String address) {
		JPanel searchPanel = new JPanel(new GridLayout(4, 2, 5, 5));

		// 添加编辑框
		searchPanel.add(new JLabel("学生ID:"));
		editStudentIdField = new JTextField();
		editStudentIdField.setText(id);
		editStudentIdField.setEditable(false);
		searchPanel.add(editStudentIdField);

		searchPanel.add(new JLabel("姓名:"));
		editNameField = new JTextField();
		editNameField.setText(name);
		editNameField.setEditable(false);
		searchPanel.add(editNameField);
		
		//生日框爆改课程名称框
		searchPanel.add(new JLabel("课程名称:"));
		dobField = new JTextField();
		dobField.setText(brith);
		dobField.setEditable(false);
		searchPanel.add(dobField);
		//电话框爆改课程代码
		searchPanel.add(new JLabel("课程代码:"));
		editPhoneField = new JTextField();
		editPhoneField.setText(phone);
		editPhoneField.setEditable(false);
		searchPanel.add(editPhoneField);

		//地址框爆改任课老师
		searchPanel.add(new JLabel("任课老师:"));
		editAddressField = new JTextField();
		editAddressField.setText(address);
		editAddressField.setEditable(false);
		searchPanel.add(editAddressField);
		
		searchPanel.add(new JLabel("成绩:"));
		editSourceField = new JTextField();
		//genderComboBox = new JComboBox<>(new String[] { "男", "女" });
		editSourceField.setText("99999999");
		editSourceField.setEditable(false);
		searchPanel.add(editSourceField);	

		

		searchPanel.add(new JLabel("密码:"));
		editPasswordField = new JTextField();
		editPasswordField.setText(password);
		searchPanel.add(editPasswordField);

		// 提交和删除按钮
		editPasswordButton = new JButton("提交修改");
		deleteButton = new JButton("删除信息");
		searchPanel.add(editPasswordButton);
		searchPanel.add(deleteButton);
		// 【删除按钮】监听器
		editPasswordButton.addActionListener(e -> handleEditPasswordButton());

		// 【修改按钮】监听器
		editPasswordButton.addActionListener(e -> handleUpdateButtonClick(0));

		return searchPanel;

	}

	public JPanel getPanel() {
		return panel;
	}

	public void addSubmitListener(ActionListener listener) {
		submitButton.addActionListener(listener);
	}

	// 更新查询面板的学生列表
	public void updateStudentTable() {
		StudentController controller = new StudentController(this.parentView);
		controller.loadStudentData();
	}

	// 更新课程表
	public void updateCourseTable() {
		CourseController controller = new CourseController(this.parentView);
		controller.loadCourseData();
	}

	// 更新用户表
	public void updateUserTable() {
		UserController controller = new UserController(this.parentView);
		controller.loadUserData();
	}

	public void displayStudents(List<String[]> students) {
		String[] columnNames = { "学生ID", "姓名", "性别", "出生日期", "电话", "地址", "密码" };
		DefaultTableModel model = new DefaultTableModel(columnNames, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false;
			}
		};
		students.forEach(student -> model.addRow(student));
		allStudentTable.setModel(model);
	}

	public void displayCourses(List<String[]> course) {
		String[] columnNames = { "课程ID", "课程名称", "课程代码", "任课老师" };
		DefaultTableModel model = new DefaultTableModel(columnNames, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false;
			}
		};
		course.forEach(student -> model.addRow(student));
		allCourseTable.setModel(model);
	}

	public void displayUsers(List<String[]> users) {
		String[] columnNames = { "用户ID", "用户实名", "用户账号", "用户密码", "角色" };
		DefaultTableModel model = new DefaultTableModel(columnNames, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false;
			}
		};
		//users.forEach(student -> model.addRow(student));
		
		// 遍历用户数据并转换角色值
	    users.forEach(user -> {
	        // 获取角色数字（角色是users数组中的第5个元素）
	        String role = user[4];
	        if ("1".equals(role)) {
	            user[4] = "老师";  // 将数字1渲染为“老师”
	        } else if ("2".equals(role)) {
	            user[4] = "管理员";  // 将数字2渲染为“管理员”
	        }
	        
	        model.addRow(user);  // 添加到表格模型中
	    });
		allUserTable.setModel(model);
	}

	// 处理【删除信息】点击事件
	private void handleDeleteButtonClick(int role) {
		if (role == 1) {
			System.out.print("删除学生，id=" + deleteID + "\n");
			// String studentId = allStudentTable.getValueAt(deleteRow, 0).toString();
			if (deleteID != -1) {
				StudentController controller = new StudentController(this.parentView);
				String studentId = allStudentTable.getValueAt(deleteRow, 0).toString();
				System.out.print("String删除学生，id=" + studentId + "\n");
				controller.deleteStudent(studentId);
				updateStudentTable();

			} else {
				System.out.print("未选中\n");
			}
		} else if (role == 2) {
			System.out.print("删除用户，id=" + deleteUserID + "\n");
			// String studentId = allStudentTable.getValueAt(deleteRow, 0).toString();
			if (deleteUserID != -1) {
				UserController controller = new UserController(this.parentView);
				String userId = allUserTable.getValueAt(deleteUserRow, 0).toString();
				System.out.print("String 删除用户，id=" + userId + "\n");
				controller.deleteUser(userId);
				updateUserTable();

			} else {
				System.out.print("未选中\n");
			}
		}

	}

	// 处理【提交修改】点击事件
	private void handleUpdateButtonClick(int role) {
		if(role == 1) {
			String studentId = editStudentIdField.getText();
			String name = editNameField.getText();
			String gender = (String) genderComboBox.getSelectedItem();
			String dob = dobField.getText();
			String phone = editPhoneField.getText();
			String address = editAddressField.getText();
			String password = editPasswordField.getText();
			StudentController controller = new StudentController(this.parentView);
			controller.updateStudent(studentId, name, gender, dob, phone, address, password);
			updateStudentTable();
		}else if(role ==2) {
			//管理员面板的修改事件
			String userId = editStudentIdField.getText();
			String realname = editRealNameField.getText();
			String name = editNameField.getText();
			String l_role = (String) roleComboBox.getSelectedItem();
			String password = editPasswordField.getText();
			UserController controller = new UserController(this.parentView);
			System.out.print("角色讲修改为：" + l_role);
			if(l_role.equals("老师")) {
				System.out.print("\n插入1\n");
				controller.updateUser(userId, name, realname, "1", password);
			}else if(l_role.equals("管理员")) {
				System.out.print("\n插入2\n");
				controller.updateUser(userId, name, realname, "2", password);
			}
			updateUserTable();
		}
	}

	// 处理【修改密码】点击事件
	private void handleEditPasswordButton() {
		String studentId = editStudentIdField.getText();
		String name = editNameField.getText();
		String gender = (String) genderComboBox.getSelectedItem();
		String dob = dobField.getText();
		String phone = editPhoneField.getText();
		String address = editAddressField.getText();
		String password = editPasswordField.getText();
		StudentController controller = new StudentController(this.parentView);
		controller.updateStudent(studentId, name, gender, dob, phone, address, password);
		updateStudentTable();
	}
}
```

这段代码展示了一个用于学生信息管理系统的查询面板。该面板具有以下几个主要功能：

1. **学生信息表格展示**：根据用户的角色（学生、老师、管理员），展示不同的数据表格，如学生信息表格、课程信息表格和用户信息表格。
2. **点击表格行填充信息**：根据用户的角色，点击表格中的行会显示该行的信息，并填充到表单字段中，用户可以修改这些信息。
3. **增、删、改功能**：用户可以对学生、课程或用户信息进行更新或删除操作。

在这段代码中，有以下几个值得注意的部分：

### 主要功能：

- **表格展示与选择**：`allStudentTable`、`allCourseTable`、`allUserTable` 表示学生表格、课程表格和用户表格，当用户点击某一行时，会触发 `mouseClicked` 事件，填充对应的编辑字段。

- 表单字段和操作按钮：

  - 学生的编辑信息字段有 `editStudentIdField`、`editNameField` 等，包含姓名、性别、出生日期、电话、地址、密码等信息。
  - 角色（如学生、老师、管理员）对应不同的表单和操作面板。
  
- 修改与删除操作：

  - 点击 **提交修改** 按钮，会触发对应的修改事件，调用 `handleUpdateButtonClick` 方法。
- 点击 **删除信息** 按钮，会触发删除操作，调用 `handleDeleteButtonClick` 方法。

### 提升代码的可维护性与可读性的一些建议：

1. **抽取重复逻辑**：当前代码中，学生、用户、课程的表格显示及表单填充逻辑有些重复，可以考虑提取公共的部分，比如`填充表格`、`填充表单`等，来减少代码重复性。
2. **改善用户体验**：
   - 在用户操作过程中，表单字段会根据所选行数据进行填充，但如果在操作过程中有数据被修改，界面不会实时反映这些更改。你可以考虑在 `handleUpdateButtonClick` 后实时更新界面。
   - 如果操作涉及网络请求或者数据库更新，增加 loading 动画或者提示可以提升用户体验，避免因长时间没有反应而认为操作失败。
3. **错误处理与提示**：在提交修改或删除时，考虑加入错误处理与提示信息，比如数据格式错误、网络错误等情况的提示。
4. **代码模块化**：为了提升代码的可维护性，可以将逻辑分为更小的模块，例如将表格展示、表单更新、数据库操作等逻辑单独抽离到各自的控制类中。

整体来说，代码结构清晰，功能完整。如果有进一步的优化或具体需求，欢迎提出。

## StudentManagerView 类

```java


package view;

import javax.swing.*;

import controller.StudentController;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;

// 主视图类，负责整合各个子组件和模块，构建完整的学生信息管理系统界面
public class StudentManagerView {

    private JFrame frame;
    private CardLayout cardLayout;
    private JPanel cardPanel;
    //封装类
    private NavigationPanel navigationPanel;
    private QueryPanel queryPanel;
    private AddPanel addPanel;
    private UpdatePanel updatePanel;
    //private DeletePanel deletePanel;

    public StudentManagerView(int role,String name,String password) {
        initialize(role,name,password);
    }

    private void initialize(int role,String name,String password) {
        frame = new JFrame("学生信息管理系统");
        frame.setBounds(100, 100, 800, 600);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().setLayout(new BorderLayout());

        // 初始化各个功能面板
        navigationPanel = new NavigationPanel(role);
        queryPanel = new QueryPanel(this,role,name,password);
        addPanel = new AddPanel(this,role);
        updatePanel = new UpdatePanel();
        //deletePanel = new DeletePanel();
        cardLayout = new CardLayout();
        cardPanel = new JPanel(cardLayout);
//        cardPanel.add(queryPanel.getPanel(), "query");
//        cardPanel.add(addPanel.getPanel(), "add");
        //cardPanel.add(updatePanel.getPanel(), "update");
        //cardPanel.add(deletePanel.getPanel(), "delete");

        frame.getContentPane().add(navigationPanel.getPanel(), BorderLayout.WEST);
        frame.getContentPane().add(cardPanel, BorderLayout.CENTER);

        // 状态栏
        if(role == 0) {
            cardPanel.add(queryPanel.getPanel(), "query");
        	JLabel statusLabel = new JLabel("当前身份：学生", JLabel.CENTER);
            statusLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
            frame.getContentPane().add(statusLabel, BorderLayout.SOUTH);
        }else if(role==1) {
        	System.out.print("老师");
            cardPanel.add(queryPanel.getPanel(), "query");
            cardPanel.add(addPanel.getPanel(), "add");
            cardPanel.add(updatePanel.getPanel(), "update");
            //cardPanel.add(deletePanel.getPanel(), "delete");
        	JLabel statusLabel = new JLabel("当前身份：老师", JLabel.CENTER);
            statusLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
            frame.getContentPane().add(statusLabel, BorderLayout.SOUTH);
        }else if(role==2) {
            cardPanel.add(queryPanel.getPanel(), "query");
            cardPanel.add(addPanel.getPanel(), "add");
            cardPanel.add(updatePanel.getPanel(), "update"); // 确保这里添加了 updatePanel
            //cardPanel.add(deletePanel.getPanel(), "delete");
        	JLabel statusLabel = new JLabel("当前身份：管理员", JLabel.CENTER);
            statusLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
            frame.getContentPane().add(statusLabel, BorderLayout.SOUTH);
        }
        

        // 处理导航按钮点击事件，关联到对应面板的显示切换
        handleNavigationButtonClicks();
    }

    private void handleNavigationButtonClicks() {
        for (JButton button : navigationPanel.getButtons()) {
            String cardName = button.getActionCommand();
            button.addActionListener(e -> cardLayout.show(cardPanel, cardName));
        }
    }

    public JFrame getFrame() {
        return frame;
    }

    public void addSubmitListener(ActionListener listener) {
        queryPanel.addSubmitListener(listener);
    }

    

    public void displayStudents(List<String[]> students) {
        queryPanel.displayStudents(students);
    }
    
    public void displayCourses(List<String[]> course) {
        queryPanel.displayCourses(course);
    }
    public void displayUsers(List<String[]> User) {
        queryPanel.displayUsers(User);
        //queryPanel.updateStudentTable();
    }
//    //管理员面板的学生信息窗口
//    public void displayUpStudentTable(List<String[]> students) {
//    	updatePanel.displayStudents(students);
//    }
    
    public void updateStudentTable() {
        queryPanel.updateStudentTable();
    }
    public void updateCourseTable() {
        queryPanel.updateCourseTable();
    }
    public void updateUserTable() {
        queryPanel.updateUserTable();
    }
}
```

代码看起来结构清晰，使用了 `CardLayout` 来切换不同的面板，以及通过角色控制不同的权限界面展示。下面是一些可以提升和优化的地方：

### 1. **避免重复的角色检查代码**

在`initialize`方法中，你为不同角色添加了很多重复的代码，例如添加各个面板以及状态栏。你可以考虑将这些重复部分提取成一个方法来减少代码重复性。例如：

```java
private void initialize(int role, String name, String password) {
    frame = new JFrame("学生信息管理系统");
    frame.setBounds(100, 100, 800, 600);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.getContentPane().setLayout(new BorderLayout());

    // 初始化各个功能面板
    navigationPanel = new NavigationPanel(role);
    queryPanel = new QueryPanel(this, role, name, password);
    addPanel = new AddPanel(this, role);
    updatePanel = new UpdatePanel();
    cardLayout = new CardLayout();
    cardPanel = new JPanel(cardLayout);

    frame.getContentPane().add(navigationPanel.getPanel(), BorderLayout.WEST);
    frame.getContentPane().add(cardPanel, BorderLayout.CENTER);

    // 添加状态栏和面板
    addRolePanelsAndStatus(role);
    
    // 处理导航按钮点击事件，关联到对应面板的显示切换
    handleNavigationButtonClicks();
}

private void addRolePanelsAndStatus(int role) {
    if (role == 0) {
        cardPanel.add(queryPanel.getPanel(), "query");
        JLabel statusLabel = new JLabel("当前身份：学生", JLabel.CENTER);
        statusLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
        frame.getContentPane().add(statusLabel, BorderLayout.SOUTH);
    } else if (role == 1) {
        cardPanel.add(queryPanel.getPanel(), "query");
        cardPanel.add(addPanel.getPanel(), "add");
        cardPanel.add(updatePanel.getPanel(), "update");
        JLabel statusLabel = new JLabel("当前身份：老师", JLabel.CENTER);
        statusLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
        frame.getContentPane().add(statusLabel, BorderLayout.SOUTH);
    } else if (role == 2) {
        cardPanel.add(queryPanel.getPanel(), "query");
        cardPanel.add(addPanel.getPanel(), "add");
        cardPanel.add(updatePanel.getPanel(), "update");
        JLabel statusLabel = new JLabel("当前身份：管理员", JLabel.CENTER);
        statusLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
        frame.getContentPane().add(statusLabel, BorderLayout.SOUTH);
    }
}
```

### 2. **`handleNavigationButtonClicks`方法优化**

目前，所有的按钮都添加了相同的监听器，这个操作是有效的，但有一点可以优化。如果每个面板的 `cardName` 是唯一的，你可以简化这部分代码，例如使用一个映射来关联按钮和面板，而不需要在 `handleNavigationButtonClicks` 中遍历所有按钮。这里可以使用`Map<String, JPanel>`来替代。

### 3.` **JPanel`布局优化**

在多个面板创建时使用了 `GridLayout`，这种布局方式比较基础，你可以根据实际的需求选择合适的布局管理器。比如在某些场景下，可以使用 `BoxLayout` 或者 `GroupLayout` 来改善面板中的元素排列。

### 4. **`addSubmitListener` 和 `displayStudents` 方法的参数**

你的`addSubmitListener`和`displayStudents`方法的参数是固定的`queryPanel`，但这可能会影响以后拓展。例如，`addSubmitListener`方法只作用于`queryPanel`，可以考虑根据传入的面板来灵活处理。

### 5. **`StatusLabel`的重复创建**

你为每个角色分别创建了`StatusLabel`，其实可以将`StatusLabel`的创建提取成一个方法，并根据角色动态更新其内容。这也有助于以后扩展时修改状态栏的逻辑。

### 总结：

代码结构和功能已经相当清晰，未来的改进点主要是减少冗余代码、增加灵活性和提高可维护性。希望上述建议能对你有帮助。如果有其他具体的实现问题，随时可以交流！



## BindView

```java
package controller;

import view.StudentManagerView;

public class BindView {
	public static void bind(int role, String name, String password) {
		// 创建视图
		StudentManagerView view = new StudentManagerView(role, name, password);
		if (role == 0) {
			System.out.print("进入学生视角");
			CourseController courseController = new CourseController(view);
			courseController.loadCourseData();
		} else if (role == 1) {
			System.out.print("进入老师视角");
			// 创建控制器，并关联视图
			StudentController teacherController = new StudentController(view);
			// 加载学生数据并显示
			teacherController.loadStudentData();
		} else if (role == 2) {
			System.out.print("进入管理员视角");
			// 创建控制器，并关联视图
			UserController userController = new UserController(view);
			// 加载用户数据并显示
			userController.loadUserData();
		}
		
		// 显示界面
		view.getFrame().setVisible(true);
	}
}
```

在`BindView`类中，绑定视图与控制器逻辑的实现很清晰，不过也有一些优化的地方，以提升代码的可扩展性和可维护性。以下是一些优化建议：

### 1. **减少冗余的代码**

目前在`bind`方法中，针对不同角色的操作非常类似（创建视图、创建控制器、加载数据等），可以考虑提取公共逻辑，减少重复代码。尤其是`loadData`部分可以提取成一个方法，使得代码更加简洁。

例如，可以定义一个通用的`loadDataForRole`方法来简化代码：

```java
public class BindView {
    public static void bind(int role, String name, String password) {
        // 创建视图
        StudentManagerView view = new StudentManagerView(role, name, password);

        // 根据角色创建相应的控制器并加载数据
        loadDataForRole(role, view);

        // 显示界面
        view.getFrame().setVisible(true);
    }

    private static void loadDataForRole(int role, StudentManagerView view) {
        switch (role) {
            case 0:
                System.out.println("进入学生视角");
                CourseController courseController = new CourseController(view);
                courseController.loadCourseData();
                break;
            case 1:
                System.out.println("进入老师视角");
                StudentController teacherController = new StudentController(view);
                teacherController.loadStudentData();
                break;
            case 2:
                System.out.println("进入管理员视角");
                UserController userController = new UserController(view);
                userController.loadUserData();
                break;
            default:
                throw new IllegalArgumentException("Unknown role: " + role);
        }
    }
}
```

**优势**：

- 使用 `switch` 可以减少冗余代码，容易扩展和修改。
- 角色的相关处理逻辑被封装到一个方法中，代码结构更加简洁。

### 2. **异常处理**

如果传入的`role`不在预期的范围内（例如角色不为0、1或2），目前的代码没有处理这种情况。你可以考虑添加异常处理或者返回一个错误信息，确保在非法输入的情况下不会导致程序崩溃。

例如：

```java
default:
    throw new IllegalArgumentException("Unknown role: " + role);
```

这种方式可以确保当有非法的`role`传入时，程序会抛出异常，提醒开发人员检查调用逻辑。

### 3. **日志输出优化**

目前使用`System.out.print`输出角色视角的消息，虽然简单有效，但在实际开发中，使用日志记录框架（如`Log4j`、`SLF4J`等）会更专业。这样做有助于日志管理，方便调试和生产环境下的日志分析。

例如，可以使用简单的`Logger`：

```java
private static final Logger logger = LoggerFactory.getLogger(BindView.class);

private static void loadDataForRole(int role, StudentManagerView view) {
    switch (role) {
        case 0:
            logger.info("进入学生视角");
            CourseController courseController = new CourseController(view);
            courseController.loadCourseData();
            break;
        case 1:
            logger.info("进入老师视角");
            StudentController teacherController = new StudentController(view);
            teacherController.loadStudentData();
            break;
        case 2:
            logger.info("进入管理员视角");
            UserController userController = new UserController(view);
            userController.loadUserData();
            break;
        default:
            throw new IllegalArgumentException("Unknown role: " + role);
    }
}
```

### 4. **可扩展性**

当前实现非常适合当前的角色设置（学生、老师、管理员），但是如果以后要添加更多角色，维护和扩展会稍显麻烦。为此，你可以考虑使用工厂模式来创建不同角色对应的控制器。这样，扩展时只需要修改工厂方法，而不需要修改`BindView`类的逻辑。

例如：

```java
public class RoleControllerFactory {
    public static Controller createController(int role, StudentManagerView view) {
        switch (role) {
            case 0:
                return new CourseController(view);
            case 1:
                return new StudentController(view);
            case 2:
                return new UserController(view);
            default:
                throw new IllegalArgumentException("Unknown role: " + role);
        }
    }
}
```

然后在`BindView`中调用工厂方法：

```java
public class BindView {
    public static void bind(int role, String name, String password) {
        // 创建视图
        StudentManagerView view = new StudentManagerView(role, name, password);

        // 使用工厂创建控制器并加载数据
        Controller controller = RoleControllerFactory.createController(role, view);
        controller.loadData();

        // 显示界面
        view.getFrame().setVisible(true);
    }
}
```

这样，扩展新角色时只需要修改`RoleControllerFactory`，而不需要修改`BindView`。

### 总结：

通过引入`switch`语句、日志框架、异常处理和工厂模式等方式，可以使代码更加简洁、易维护和易扩展。希望这些建议对你有所帮助！

# 实体类

## CourseController 类

```java
package controller;

import model.DatabaseManager;
import view.StudentManagerView;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class CourseController {

    private StudentManagerView view;

    public CourseController(StudentManagerView view) {
        this.view = view;
    }

    // 加载数据库数据
    public void loadCourseData() {
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        List<String[]> courses = new ArrayList<>();

        try {
            connection = DatabaseManager.getConnection();
            String query = "SELECT * FROM course";
            statement = connection.createStatement();
            resultSet = statement.executeQuery(query);

            while (resultSet.next()) {
                String courseId = String.valueOf(resultSet.getInt("course_id"));
                String courseName = resultSet.getString("course_name");
                String coursePhone = resultSet.getString("course_code");
                String courseAddress = resultSet.getString("teacher_name");

                courses.add(new String[] { courseId, courseName, coursePhone, courseAddress });
            }

            view.displayCourses(courses);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            DatabaseManager.closeConnection(connection, statement, resultSet);
        }
    }

    public double showCurseSource(int student, int course) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            connection = DatabaseManager.getConnection();
            String searchCourse = "SELECT score FROM grade WHERE student_id =? AND course_id =?";
            preparedStatement = connection.prepareStatement(searchCourse);
            preparedStatement.setInt(1, student);
            preparedStatement.setInt(2, course);
            resultSet = preparedStatement.executeQuery();

            if (resultSet.next()) {
                double doubleValue = resultSet.getDouble("score");
                return doubleValue;
            }
            return -1;  // 如果没有查询到成绩，返回-1
        } catch (SQLException e) {
            e.printStackTrace();
            return -1;  // 出现异常也返回-1
        } finally {
            DatabaseManager.closeConnection(connection, preparedStatement, resultSet);
        }
    }
}
```

你的`CourseController`类实现了课程数据的加载和成绩查询功能，代码整体上看起来不错，但有一些可以优化和改进的地方。以下是一些建议：

### 1. **异常处理改进**

在数据库操作中，当前异常的处理只是通过打印堆栈信息（`e.printStackTrace()`）。通常情况下，打印堆栈并不适合在生产环境中使用，特别是对用户暴露数据库错误信息时，应该更友好地处理异常并记录日志。

可以使用日志框架（如`SLF4J`与`Logback`）来记录异常，而不是仅仅打印堆栈。这样在生产环境中，日志会帮助开发人员更好地跟踪错误。

示例：

```java
private static final Logger logger = LoggerFactory.getLogger(CourseController.class);

public void loadCourseData() {
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    List<String[]> courses = new ArrayList<>();

    try {
        connection = DatabaseManager.getConnection();
        String query = "SELECT * FROM course";
        statement = connection.createStatement();
        resultSet = statement.executeQuery(query);

        while (resultSet.next()) {
            String courseId = String.valueOf(resultSet.getInt("course_id"));
            String courseName = resultSet.getString("course_name");
            String coursePhone = resultSet.getString("course_code");
            String courseAddress = resultSet.getString("teacher_name");

            courses.add(new String[] { courseId, courseName, coursePhone, courseAddress });
        }

        view.displayCourses(courses);
    } catch (SQLException e) {
        logger.error("加载课程数据时出错", e);
    } finally {
        DatabaseManager.closeConnection(connection, statement, resultSet);
    }
}
```

通过使用`logger`，可以在日志文件中查看具体的错误信息，而不会直接暴露堆栈信息给用户。

### 2. **数据库连接池**

每次进行数据库操作时，都使用`DatabaseManager.getConnection()`来获取连接。频繁的打开和关闭数据库连接会带来性能问题，特别是在用户量较多时。可以考虑使用数据库连接池（例如`HikariCP`、`Apache DBCP`或`C3P0`）来管理数据库连接，以提高系统的性能和可伸缩性。

使用连接池的优势：

- 减少了每次数据库操作时打开新连接的开销。
- 提高了数据库连接的复用率。

### 3. **SQL优化**

在`loadCourseData`方法中，你直接执行`SELECT * FROM course`，这会选择所有列。通常情况下，查询时尽量选择需要的字段，而不是使用`*`，尤其是表中字段较多时，这样可以减少不必要的数据传输。

改进建议：

```java
String query = "SELECT course_id, course_name, course_code, teacher_name FROM course";
```

这样只查询你需要的字段，提高了查询效率。

### 4. **提高代码的可读性和扩展性**

在`showCurseSource`方法中，`SQL`查询代码、错误处理和资源管理被放在一个方法里。为了提高代码的可读性，可以考虑将SQL查询、连接管理等部分提取到单独的辅助方法中。

例如：

```java
private double getCourseScore(int studentId, int courseId) throws SQLException {
    String query = "SELECT score FROM grade WHERE student_id =? AND course_id =?";
    try (Connection connection = DatabaseManager.getConnection();
         PreparedStatement preparedStatement = connection.prepareStatement(query)) {
        preparedStatement.setInt(1, studentId);
        preparedStatement.setInt(2, courseId);
        try (ResultSet resultSet = preparedStatement.executeQuery()) {
            if (resultSet.next()) {
                return resultSet.getDouble("score");
            }
            return -1;  // If no score found, return -1
        }
    }
}

public double showCurseSource(int student, int course) {
    try {
        return getCourseScore(student, course);
    } catch (SQLException e) {
        logger.error("查询成绩时出错", e);
        return -1;  // Return -1 in case of exception
    }
}
```

这样，`getCourseScore`方法负责执行数据库查询，而`showCurseSource`方法则处理异常并调用该方法。这样代码会更清晰，且更容易进行单元测试。

### 5. **代码注释和文档**

虽然代码本身比较简洁，但对于重要的数据库查询和业务逻辑，最好添加一些注释，尤其是关于查询的目的和如何处理特殊情况的说明。这样有助于后期开发人员理解代码并维护系统。

例如：

```java
// 获取课程成绩，若未找到则返回-1
public double showCurseSource(int student, int course) {
    try {
        return getCourseScore(student, course);
    } catch (SQLException e) {
        logger.error("查询成绩时出错", e);
        return -1;
    }
}
```

### 6. **进一步简化方法**

`DatabaseManager`类的`closeConnection`方法可以通过`try-with-resources`语法进行简化，减少`finally`块中的代码。例如，`Connection`、`PreparedStatement`和`ResultSet`都可以实现`AutoCloseable`接口，这样可以自动管理资源关闭。

使用`try-with-resources`：

```java
try (Connection connection = DatabaseManager.getConnection();
     PreparedStatement preparedStatement = connection.prepareStatement(query);
     ResultSet resultSet = preparedStatement.executeQuery()) {
    if (resultSet.next()) {
        return resultSet.getDouble("score");
    }
    return -1;
} catch (SQLException e) {
    logger.error("查询成绩时出错", e);
    return -1;
}
```

### 7. **建议删除冗余代码**

如果你没有使用过`addStudent`、`updateStudent`和`deleteStudent`等方法，你可以将它们暂时注释或删除，以便更清晰地专注于课程和成绩查询功能。

这些方法如果以后有需要，可以单独整理为一个学生管理类中的方法，而不必放在`CourseController`类中。

------

### 总结

- **日志记录**：引入日志框架记录异常，代替打印堆栈信息。
- **数据库连接池**：考虑使用连接池提高性能。
- **`SQL`查询优化**：避免使用`SELECT *`，只查询需要的字段。
- **代码结构优化**：提取重复的`SQL`查询代码，使用`try-with-resources`语法简化资源管理。
- **注释和文档**：对复杂逻辑进行注释，方便团队成员理解和维护。

这些改进将使代码更加健壮、易于维护，并在系统扩展时更加灵活。





## StudentController 类

```java
package controller;

import model.DatabaseManager;
import view.StudentManagerView;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class StudentController {

	private StudentManagerView view;

	public StudentController(StudentManagerView view) {
		this.view = view;
	}

	// 加载数据库数据
	public void loadStudentData() {
		Connection connection = null;
		Statement statement = null;
		ResultSet resultSet = null;
		List<String[]> students = new ArrayList<>();

		try {
			connection = DatabaseManager.getConnection();
			String query = "SELECT * FROM students";
			statement = connection.createStatement();
			resultSet = statement.executeQuery(query);

			while (resultSet.next()) {
				String studentId = String.valueOf(resultSet.getInt("student_id"));
				String name = resultSet.getString("name");
				String gender = resultSet.getString("gender");
				String birthDate = resultSet.getDate("birth_date").toString();
				String phone = resultSet.getString("phone");
				String address = resultSet.getString("address");
				String password = resultSet.getString("password");
				students.add(new String[] { studentId, name, gender, birthDate, phone, address, password });
			}

			view.displayStudents(students);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, statement, resultSet);
		}
	}

	// 添加学生到数据库
	public void addStudent(String studentId, String name, String gender, String birthDate, String phone, String address,
			String password) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		try {
			connection = DatabaseManager.getConnection();
			String insertQuery = "INSERT INTO students (student_id, name, gender, birth_date, phone, address,password) VALUES (?, ?, ?, ?, ?, ?,?)";
			preparedStatement = connection.prepareStatement(insertQuery);

			preparedStatement.setString(1, studentId);
			preparedStatement.setString(2, name);
			preparedStatement.setString(3, gender);
			preparedStatement.setString(4, birthDate);
			preparedStatement.setString(5, phone);
			preparedStatement.setString(6, address);
			preparedStatement.setString(7, password);
			int rowsAffected = preparedStatement.executeUpdate();
			if (rowsAffected > 0) {
				System.out.println("学生信息添加成功");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, null);
		}
	}

	// 更新学生信息
	public void updateStudent(String studentId, String name, String gender, String birthDate, String phone,
			String address, String password) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		try {
			connection = DatabaseManager.getConnection();
			String updateQuery = "UPDATE students SET name = ?, gender = ?, birth_date = ?, phone = ?, address = ?, password= ? WHERE student_id = ?";
			preparedStatement = connection.prepareStatement(updateQuery);

			preparedStatement.setString(1, name);
			preparedStatement.setString(2, gender);
			preparedStatement.setString(3, birthDate);
			preparedStatement.setString(4, phone);
			preparedStatement.setString(5, address);
			preparedStatement.setString(6, password);
			preparedStatement.setString(7, studentId);

			int rowsAffected = preparedStatement.executeUpdate();
			if (rowsAffected > 0) {
				System.out.println("学生信息修改成功");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, null);
		}
	}

	// 删除学生信息
	public void deleteStudent(String studentId) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		try {
			connection = DatabaseManager.getConnection();
			String deleteQuery = "DELETE FROM students WHERE student_id = ?";
			preparedStatement = connection.prepareStatement(deleteQuery);
			preparedStatement.setString(1, studentId);

			int rowsAffected = preparedStatement.executeUpdate();
			if (rowsAffected > 0) {
				System.out.println("学生信息删除成功");
			} else {
				System.out.println("未找到该学生，删除失败");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, null);
		}
	}

	// 获取当前最大的id值
	public int getMaxStudentId() {
		int maxStudentId = 0;
		Connection connection = null;
		Statement statement = null;
		ResultSet resultSet = null;

		try {
			// 获取数据库连接
			connection = DatabaseManager.getConnection();

			// 查询最大学生ID
			String query = "SELECT MAX(student_id) FROM students"; // 根据你的表和字段名称进行调整
			statement = connection.createStatement();
			resultSet = statement.executeQuery(query);
			// 获取查询结果
			if (resultSet.next()) {
				maxStudentId = resultSet.getInt(1); // 获取最大学生ID
			}

		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			// 关闭资源
			DatabaseManager.closeConnection(connection, statement, resultSet);
		}

		return maxStudentId; // 返回最大学生ID
	}

	// 根据名字和密码返回用户的其它信息
	public List<String[]> getStudentByNameAndPassword(String name, String password) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		List<String[]> studentInfoList = new ArrayList<>();

		try {
			connection = DatabaseManager.getConnection();
			String query = "SELECT student_id, gender, birth_date, phone, address FROM students WHERE name =? AND password =?";
			preparedStatement = connection.prepareStatement(query);
			preparedStatement.setString(1, name);
			preparedStatement.setString(2, password);
			resultSet = preparedStatement.executeQuery();

			while (resultSet.next()) {
				String studentId = String.valueOf(resultSet.getInt("student_id"));
				String gender = resultSet.getString("gender");
				String birthDate = resultSet.getDate("birth_date").toString();
				String phone = resultSet.getString("phone");
				String address = resultSet.getString("address");
				studentInfoList.add(new String[] { studentId, gender, birthDate, phone, address });
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, resultSet);
		}

		return studentInfoList;
	}

}
```

你的 `StudentController` 类已经实现了学生管理系统的基本功能，如加载学生数据、添加学生、更新学生信息、删除学生以及通过姓名和密码查询学生信息等功能。代码整体上比较清晰，但仍然有一些可以优化和改进的地方。以下是一些建议：

### 1. **数据库连接池的使用**

就像前面提到的，频繁的数据库连接会带来性能问题。使用数据库连接池来优化数据库连接的创建和管理，尤其在系统扩展时非常有用。你可以考虑使用像 `HikariCP` 或 `Apache DBCP` 这样的连接池框架。

例如：

```java
private static final HikariDataSource dataSource = new HikariDataSource();

public static Connection getConnection() throws SQLException {
    return dataSource.getConnection();
}
```

通过连接池管理数据库连接可以显著提高系统的性能和可伸缩性。

### 2. **异常处理和日志记录**

当前代码中的异常处理只是通过 `e.printStackTrace()` 打印堆栈信息。为了提高代码的健壮性，可以使用日志框架（如 `SLF4J` + `Logback`）来记录异常信息，而不是直接在控制台打印。

例如：

```java
private static final Logger logger = LoggerFactory.getLogger(StudentController.class);

public void loadStudentData() {
    // ...
    try {
        // Database operations
    } catch (SQLException e) {
        logger.error("加载学生数据时发生错误", e);
    } finally {
        DatabaseManager.closeConnection(connection, statement, resultSet);
    }
}
```

通过日志记录，你可以更容易地追踪错误，并能够在生产环境中避免将详细的错误信息暴露给用户。

### 3. **`SQL`查询优化**

在某些查询中，例如 `loadStudentData` 方法中，你使用了 `SELECT *` 来查询所有列。这通常不推荐，尤其是当表中列很多时，只查询你需要的列会更高效。

例如，改进查询：

```java
String query = "SELECT student_id, name, gender, birth_date, phone, address, password FROM students";
```

这样可以避免不必要的列数据传输，提升查询效率。

### 4. **简化数据库操作**

当前的数据库操作每次都要创建一个新的连接，关闭连接等操作。你可以提取出一个公共方法来简化代码。特别是数据库的 `Connection`、`PreparedStatement`、`ResultSet` 的关闭操作，可以通过 `try-with-resources` 来自动管理资源。

例如：

```java
try (Connection connection = DatabaseManager.getConnection();
     PreparedStatement preparedStatement = connection.prepareStatement(query);
     ResultSet resultSet = preparedStatement.executeQuery()) {
    // 处理结果集
} catch (SQLException e) {
    logger.error("数据库操作错误", e);
}
```

这样不仅简化了代码，也避免了忘记关闭资源的问题。

### 5. **代码的可维护性**

对于一些重复的数据库操作（如添加、更新、删除学生等），可以考虑提取出通用的数据库操作方法，使得代码更具可维护性和可扩展性。例如，创建一个通用的 `executeUpdate` 方法来执行插入、更新和删除操作。

例如：

```java
private void executeUpdate(String query, Object[] params) throws SQLException {
    try (Connection connection = DatabaseManager.getConnection();
         PreparedStatement preparedStatement = connection.prepareStatement(query)) {
        for (int i = 0; i < params.length; i++) {
            preparedStatement.setObject(i + 1, params[i]);
        }
        preparedStatement.executeUpdate();
    }
}
```

然后你可以将添加、更新、删除学生的方法重构为：

```java
public void addStudent(String studentId, String name, String gender, String birthDate, String phone, String address, String password) {
    String query = "INSERT INTO students (student_id, name, gender, birth_date, phone, address, password) VALUES (?, ?, ?, ?, ?, ?, ?)";
    Object[] params = { studentId, name, gender, birthDate, phone, address, password };
    try {
        executeUpdate(query, params);
        System.out.println("学生信息添加成功");
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```

### 6. **避免硬编码**

在查询语句中，硬编码了字段名称、表名称等。为了避免这种硬编码，可以考虑将这些内容提取为常量或者配置文件中的配置项。

例如：

```java
private static final String TABLE_NAME = "students";
private static final String COLUMN_STUDENT_ID = "student_id";
private static final String COLUMN_NAME = "name";
private static final String COLUMN_GENDER = "gender";
// ...
```

### 7. **进一步细化`getStudentByNameAndPassword`方法**

目前的 `getStudentByNameAndPassword` 方法返回了学生的基本信息，但你可以考虑返回更详细的用户信息对象（如 `Student` 类），而不是使用 `String[]`。这样不仅能提高代码的可读性，还能更容易地扩展功能。

例如：

```java
public class Student {
    private String studentId;
    private String gender;
    private String birthDate;
    private String phone;
    private String address;

    // 构造器、getter 和 setter
}

public List<Student> getStudentByNameAndPassword(String name, String password) {
    List<Student> studentList = new ArrayList<>();
    String query = "SELECT student_id, gender, birth_date, phone, address FROM students WHERE name =? AND password =?";
    try (Connection connection = DatabaseManager.getConnection();
         PreparedStatement preparedStatement = connection.prepareStatement(query)) {
        preparedStatement.setString(1, name);
        preparedStatement.setString(2, password);
        try (ResultSet resultSet = preparedStatement.executeQuery()) {
            while (resultSet.next()) {
                Student student = new Student(
                    String.valueOf(resultSet.getInt("student_id")),
                    resultSet.getString("gender"),
                    resultSet.getDate("birth_date").toString(),
                    resultSet.getString("phone"),
                    resultSet.getString("address")
                );
                studentList.add(student);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return studentList;
}
```

这样 `getStudentByNameAndPassword` 返回的是 `Student` 对象，调用者可以直接使用这些对象而不需要解析字符串数组。

### 总结：

- **使用日志框架** 记录错误，避免使用 `e.printStackTrace()`。
- **优化数据库连接**，使用连接池来提高性能。
- **简化数据库操作**，可以提取出通用的数据库操作方法。
- **减少硬编码**，使用常量或者配置文件来管理字段名称。
- **返回对象而非数组**，通过返回模型类（如 `Student`）来提高代码的可读性和可扩展性。

这些改进可以提高代码的可维护性、性能和可扩展性。



## UserController 类

```java
package controller;

import model.DatabaseManager;
import model.User;
import view.StudentManagerView;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class UserController {
	private StudentManagerView view;

	public UserController(StudentManagerView view) {
		this.view = view;
	}

	// 登录验证方法
	public boolean login(String username, String password, String role) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;

		try {
			connection = DatabaseManager.getConnection();
			String query = "SELECT * FROM User WHERE username = ? AND password = ? AND role = ?";
			preparedStatement = connection.prepareStatement(query);
			preparedStatement.setString(1, username);
			preparedStatement.setString(2, password);
			preparedStatement.setString(3, role);
			resultSet = preparedStatement.executeQuery();

			// 如果查询结果存在，表示验证通过
			if (resultSet.next()) {
				return true;
			} else {
				return false;
			}

		} catch (SQLException e) {
			e.printStackTrace();
			return false;
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, resultSet);
		}
	}

	// 登录验证方法
	public boolean studentLogin(String username, String password) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;

		try {
			connection = DatabaseManager.getConnection();
			String query = "SELECT * FROM students WHERE name = ? AND password = ?";
			preparedStatement = connection.prepareStatement(query);
			preparedStatement.setString(1, username);
			preparedStatement.setString(2, password);
			// preparedStatement.setString(3, role);
			resultSet = preparedStatement.executeQuery();

			// 如果查询结果存在，表示验证通过
			if (resultSet.next()) {
				return true;
			} else {
				return false;
			}

		} catch (SQLException e) {
			e.printStackTrace();
			return false;
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, resultSet);
		}
	}

	// 根据用户名获取用户信息
	public User getUserByUsername(String username) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;

		try {
			connection = DatabaseManager.getConnection();
			String query = "SELECT * FROM User WHERE username = ?";
			preparedStatement = connection.prepareStatement(query);
			preparedStatement.setString(1, username);

			resultSet = preparedStatement.executeQuery();

			if (resultSet.next()) {
				int id = resultSet.getInt("id");
				String name = resultSet.getString("name");
				String password = resultSet.getString("password");
				int role = resultSet.getInt("role");
				return new User(id, name, username, password, role);
			} else {
				return null;
			}
		} catch (SQLException e) {
			e.printStackTrace();
			return null;
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, resultSet);
		}
	}

	// 添加学生到数据库
	public void addUser(String userId, String userName, String name, String role, String password) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		try {
			connection = DatabaseManager.getConnection();
			String insertQuery = "INSERT INTO user (id, name, username,role, password) VALUES (?,?, ?, ?,?)";
			preparedStatement = connection.prepareStatement(insertQuery);

			preparedStatement.setString(1, userId);
			preparedStatement.setString(2, userName);
			preparedStatement.setString(3, name);
			preparedStatement.setString(4, role);
			preparedStatement.setString(5, password);
			int rowsAffected = preparedStatement.executeUpdate();
			if (rowsAffected > 0) {
				System.out.println("用户信息添加成功");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, null);
		}
	}

	// 加载数据库数据
	public void loadUserData() {
		Connection connection = null;
		Statement statement = null;
		ResultSet resultSet = null;
		List<String[]> users = new ArrayList<>();

		try {
			connection = DatabaseManager.getConnection();
			String query = "SELECT * FROM user";
			statement = connection.createStatement();
			resultSet = statement.executeQuery(query);

			while (resultSet.next()) {
				String courseId = String.valueOf(resultSet.getInt("id"));
				String courseName = resultSet.getString("name");
				String courseUserName = resultSet.getString("username");
				String coursePassword = resultSet.getString("password");
				String courseRole = resultSet.getString("role");

				users.add(new String[] { courseId, courseName, courseUserName, coursePassword, courseRole });
			}

			view.displayUsers(users);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, statement, resultSet);
		}
	}

	// 删除学生信息
	public void deleteUser(String userId) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		try {
			connection = DatabaseManager.getConnection();
			String deleteQuery = "DELETE FROM user WHERE id = ?";
			preparedStatement = connection.prepareStatement(deleteQuery);
			preparedStatement.setString(1, userId);

			int rowsAffected = preparedStatement.executeUpdate();
			if (rowsAffected > 0) {
				System.out.println("用户信息删除成功");
			} else {
				System.out.println("未找到该学生，删除失败");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DatabaseManager.closeConnection(connection, preparedStatement, null);
		}
	}
	
	// 更新学生信息
    public void updateUser(String userId, String name,String realname, String role, String password) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try {
            connection = DatabaseManager.getConnection();
            String updateQuery = "UPDATE user SET name = ?, username = ?, password = ?, role = ? WHERE id = ?";
            preparedStatement = connection.prepareStatement(updateQuery);

            preparedStatement.setString(1, realname);
            preparedStatement.setString(2, name);
            preparedStatement.setString(3, password);
            preparedStatement.setString(4, role);
            preparedStatement.setString(5, userId);

            int rowsAffected = preparedStatement.executeUpdate();
            if (rowsAffected > 0) {
                System.out.println("用户信息修改成功");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            DatabaseManager.closeConnection(connection, preparedStatement, null);
        }
    }
}
```

 `UserController` 类已经实现了用户管理的基本功能，如用户登录验证、用户信息获取、添加用户、更新用户、删除用户等操作。以下是一些优化反向，以提高代码的可维护性、性能和安全性。

### 1. **登录验证的优化**

在登录验证部分，你的两个方法（`login` 和 `studentLogin`）都在进行类似的操作。可以将它们合并成一个通用的验证方法，根据角色不同调整查询条件。这样可以减少重复代码。

例如：

```java
public boolean login(String username, String password, String role) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;

    try {
        connection = DatabaseManager.getConnection();
        String query = "SELECT * FROM User WHERE username = ? AND password = ?";
        if (role != null) {
            query += " AND role = ?";
        }
        preparedStatement = connection.prepareStatement(query);
        preparedStatement.setString(1, username);
        preparedStatement.setString(2, password);
        if (role != null) {
            preparedStatement.setString(3, role);
        }
        resultSet = preparedStatement.executeQuery();

        return resultSet.next();  // 如果查询结果存在，表示验证通过
    } catch (SQLException e) {
        e.printStackTrace();
        return false;
    } finally {
        DatabaseManager.closeConnection(connection, preparedStatement, resultSet);
    }
}
```

这样可以根据 `role` 参数的不同来动态调整查询条件，同时减少代码的重复。

### 2. **`SQL`注入防范**

在数据库查询时，使用 `PreparedStatement` 已经有效地避免了 SQL 注入问题，这是一个良好的做法。继续保持这个方式，避免直接拼接 `SQL` 查询字符串。

### 3. **日志记录**

在你的 `catch` 块中，当前是通过 `e.printStackTrace()` 打印错误信息。建议使用日志框架（如 SLF4J + Logback）记录日志，这样可以更容易追踪问题，并且在生产环境中能有更好的日志管理。

例如：

```java
private static final Logger logger = LoggerFactory.getLogger(UserController.class);

public boolean login(String username, String password, String role) {
    try {
        // 数据库操作...
    } catch (SQLException e) {
        logger.error("登录验证失败, 用户名: " + username, e);
        return false;
    }
}
```

这样，你就可以记录详细的日志，并能够在遇到问题时进行排查。

### 4. **改进返回的结果类型**

你的 `getUserByUsername` 方法返回了一个 `User` 对象，这样是好的，因为它使得代码更加面向对象。如果返回的数据非常简单，考虑将 `User` 类与 `Student` 类做适当的解耦。你可以将 `User` 类的角色字段 (`role`) 映射为枚举类型（例如：`ADMIN`, `STUDENT` 等），这将提高代码的可读性和可维护性。

例如：

```java
public enum Role {
    ADMIN, STUDENT
}

public class User {
    private int id;
    private String name;
    private String username;
    private String password;
    private Role role;

    // constructor, getters, setters
}
```

在数据库操作时，可以将 `role` 字段转为枚举类型：

```java
Role role = Role.valueOf(resultSet.getString("role"));
```

这样，`role` 的值就变得更加语义化，且不容易出错。

### 5. **数据库连接管理**

目前每次操作数据库时都创建新的连接，你可以考虑将数据库连接池引入项目，以提高数据库连接的复用性，避免频繁创建和销毁连接。

例如：

```java
private static final HikariDataSource dataSource = new HikariDataSource();

public static Connection getConnection() throws SQLException {
    return dataSource.getConnection();
}
```

这样做能够减少数据库连接的开销，提高性能。

### 6. **删除用户的改进**

在删除用户的过程中，应该加入更多的异常处理与日志记录，以便在发生错误时能够及时追踪。

例如：

```java
public void deleteUser(String userId) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;

    try {
        connection = DatabaseManager.getConnection();
        String deleteQuery = "DELETE FROM user WHERE id = ?";
        preparedStatement = connection.prepareStatement(deleteQuery);
        preparedStatement.setString(1, userId);

        int rowsAffected = preparedStatement.executeUpdate();
        if (rowsAffected > 0) {
            logger.info("用户信息删除成功, 用户ID: {}", userId);
        } else {
            logger.warn("未找到该用户，删除失败, 用户ID: {}", userId);
        }
    } catch (SQLException e) {
        logger.error("删除用户时发生错误, 用户ID: " + userId, e);
    } finally {
        DatabaseManager.closeConnection(connection, preparedStatement, null);
    }
}
```

这样你就能有效地记录每一次操作的结果，无论是成功还是失败。

### 7. **更强的类型安全**

你现在在操作数据库时使用了 `String[]` 来存储用户信息数据。推荐使用强类型对象（如 `User` 类）来替代 `String[]`，这样可以减少数据格式的错误，提高代码的类型安全性。

例如，将 `loadUserData` 方法中的 `String[]` 改为返回 `List<User>`：

```java
public void loadUserData() {
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    List<User> users = new ArrayList<>();

    try {
        connection = DatabaseManager.getConnection();
        String query = "SELECT * FROM user";
        statement = connection.createStatement();
        resultSet = statement.executeQuery(query);

        while (resultSet.next()) {
            int id = resultSet.getInt("id");
            String name = resultSet.getString("name");
            String username = resultSet.getString("username");
            String password = resultSet.getString("password");
            String role = resultSet.getString("role");

            User user = new User(id, name, username, password, Role.valueOf(role));
            users.add(user);
        }

        view.displayUsers(users);
    } catch (SQLException e) {
        logger.error("加载用户数据时发生错误", e);
    } finally {
        DatabaseManager.closeConnection(connection, statement, resultSet);
    }
}
```

这样做可以使你的代码更加面向对象，减少出错的可能性。

### 8. **防止硬编码**

类似于数据库表名 `User` 和字段名 `id`, `name` 等，建议将这些常量提取到常量类中，或者通过配置文件管理。这样可以避免硬编码，并且便于维护和修改。

例如：

```java
public class UserTable {
    public static final String TABLE_NAME = "user";
    public static final String COLUMN_ID = "id";
    public static final String COLUMN_USERNAME = "username";
    // ...
}
```

### 总结：

1. **合并相似的登录方法**，减少代码重复。
2. **使用日志框架** 代替 `printStackTrace()`，方便错误追踪。
3. **返回强类型对象**，避免使用 `String[]`，提高代码的类型安全。
4. **优化数据库连接管理**，考虑使用连接池。
5. **防止硬编码**，将表名和字段名提取为常量。
6. **增强异常处理和日志记录**，帮助排查问题。
7. **使用枚举类型** 处理角色（role）字段，增加可读性和可维护性。

这些优化将提升代码的可维护性、可扩展性和性能，同时提高代码的健壮性和安全性。







## DatabaseManager 类

```java
package model;

import java.sql.*;

public class DatabaseManager {

    // 数据库连接信息
    private static final String URL = "jdbc:mysql://localhost:3306/students";
    private static final String USER = "root";       // 请替换为你的数据库用户名
    private static final String PASSWORD = "000000";  // 请替换为你的数据库密码

    // 获取数据库连接
    public static Connection getConnection() throws SQLException {
        try {
            // 加载JDBC驱动
            Class.forName("com.mysql.cj.jdbc.Driver");
            return DriverManager.getConnection(URL, USER, PASSWORD);
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
            throw new SQLException("数据库连接失败！");
        }
    }

    // 关闭连接
    public static void closeConnection(Connection connection, Statement statement, ResultSet resultSet) {
        try {
            if (resultSet != null) resultSet.close();
            if (statement != null) statement.close();
            if (connection != null) connection.close();
		} catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

 `DatabaseManager` 类功能实现很好，已经包括了获取数据库连接和关闭连接的基本操作。下面是一些优化方向，以进一步提高代码的可扩展性、健壮性和性能。

### 1. **数据库连接池的引入**

目前你的代码是每次需要数据库连接时都会创建一个新的连接，这种做法会带来连接创建和销毁的开销。在高并发的情况下，这会显著影响性能。因此，建议使用数据库连接池来管理数据库连接。`HikariCP` 是一个轻量级、高性能的数据库连接池库，广泛应用于Java项目中。

**如何使用 `HikariCP`：**

1. 在 `pom.xml` 中加入 `HikariCP` 依赖（如果你使用` Maven`）：

```
xml复制代码<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>5.0.0</version>
</dependency>
```

1. 修改 `DatabaseManager` 类，使用 `HikariCP` 来管理连接池：

```java
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

public class DatabaseManager {

    // 数据库连接池
    private static HikariDataSource dataSource;

    // 初始化数据库连接池
    static {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/students");
        config.setUsername("root");  // 请替换为你的数据库用户名
        config.setPassword("000000"); // 请替换为你的数据库密码
        config.setDriverClassName("com.mysql.cj.jdbc.Driver");
        config.setMaximumPoolSize(10);  // 最大连接池数量，可以根据需求调整
        config.setConnectionTimeout(30000); // 连接超时，单位毫秒
        config.setIdleTimeout(600000);    // 空闲连接的最大存活时间，单位毫秒
        dataSource = new HikariDataSource(config);
    }

    // 获取数据库连接
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    // 关闭连接
    public static void closeConnection(Connection connection, Statement statement, ResultSet resultSet) {
        try {
            if (resultSet != null) resultSet.close();
            if (statement != null) statement.close();
            if (connection != null) connection.close();  // 注意：连接会被返回到连接池中，而不是被彻底关闭
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

使用连接池的优点：

- **性能提升**：连接池能避免频繁的连接创建和销毁，减少开销。
- **管理简便**：连接池能够智能管理连接，自动回收空闲连接。
- **高并发支持**：能够更好地支持高并发应用，连接池提供了连接复用。

### 2. **SQL异常处理与日志记录**

在捕获 `SQLException` 时，当前代码只打印了堆栈信息。为了更好的可追溯性，建议使用日志框架（如 `SLF4J + Logback`）记录详细的异常信息。

例如：

```java
private static final Logger logger = LoggerFactory.getLogger(DatabaseManager.class);

public static Connection getConnection() throws SQLException {
    try {
        return dataSource.getConnection();
    } catch (SQLException e) {
        logger.error("获取数据库连接失败", e);
        throw new SQLException("数据库连接失败", e);
    }
}
```

这样，你就能够方便地通过日志文件跟踪问题，尤其是在生产环境中，能更清晰地记录和查看异常信息。

### 3. **数据库连接配置的灵活性**

将数据库连接信息（如 URL、用户名、密码等）提取到配置文件中（如 `application.properties` 或 `config.properties`），而不是硬编码在代码中，这样能提高代码的可维护性，并且在不同环境下（如开发、测试、生产）可以灵活配置。

例如，在 `config.properties` 中配置：

```java
db.url=jdbc:mysql://localhost:3306/students
db.username=root
db.password=000000
db.driver=com.mysql.cj.jdbc.Driver
```

在代码中读取：

```java
import java.util.Properties;
import java.io.InputStream;

public class DatabaseManager {
    private static HikariDataSource dataSource;

    static {
        Properties properties = new Properties();
        try (InputStream input = DatabaseManager.class.getClassLoader().getResourceAsStream("config.properties")) {
            if (input == null) {
                System.out.println("Sorry, unable to find config.properties");
                return;
            }
            properties.load(input);
            
            HikariConfig config = new HikariConfig();
            config.setJdbcUrl(properties.getProperty("db.url"));
            config.setUsername(properties.getProperty("db.username"));
            config.setPassword(properties.getProperty("db.password"));
            config.setDriverClassName(properties.getProperty("db.driver"));
            config.setMaximumPoolSize(10);
            config.setConnectionTimeout(30000);
            config.setIdleTimeout(600000);
            dataSource = new HikariDataSource(config);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    public static void closeConnection(Connection connection, Statement statement, ResultSet resultSet) {
        try {
            if (resultSet != null) resultSet.close();
            if (statement != null) statement.close();
            if (connection != null) connection.close();  // 连接会被返回到连接池中
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

这种做法提高了配置的灵活性，特别适合需要部署到不同环境中的应用。

### 4. **SQL 执行操作的优化**

当前的 `getConnection` 和 `closeConnection` 方法设计很好，但在使用数据库连接时，可以考虑使用 `try-with-resources` 来自动管理资源，这样不需要显式地调用 `closeConnection`。

例如：

```java
public static void executeQuery(String query) {
    String sql = "SELECT * FROM users WHERE username = ?";
    try (Connection connection = getConnection();
         PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
        preparedStatement.setString(1, "testUser");
        try (ResultSet resultSet = preparedStatement.executeQuery()) {
            while (resultSet.next()) {
                // 处理结果
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```

这样做的好处是即使发生异常，`try-with-resources` 也能确保连接、语句和结果集被自动关闭，从而避免了资源泄漏。

### 总结：

1. **引入数据库连接池**（如 `HikariCP`）来提升性能和管理数据库连接。
2. **使用日志框架**（如 `SLF4J + Logback`）记录数据库操作中的异常，增强可追溯性。
3. **将数据库连接配置提取到配置文件**，提高代码的灵活性和可维护性。
4. **使用 try-with-resources** 自动管理数据库资源，简化代码并避免资源泄漏。

通过这些优化，数据库操作将变得更加高效、安全、易维护，同时增强了代码的可扩展性和灵活性。







## Student类

```java
package model;

import java.sql.Timestamp;

public class Student {
    private int studentId;
    private String name;
    private String gender;
    private int age;
    private String grade;
    private String major;
    private Timestamp createdAt;
    private Timestamp updatedAt;

    // 构造方法
    public Student(int studentId, String name, String gender, int age, String grade, String major, Timestamp createdAt, Timestamp updatedAt) {
        this.studentId = studentId;
        this.name = name;
        this.gender = gender;
        this.age = age;
        this.grade = grade;
        this.major = major;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    // Getter 和 Setter 方法

    public int getStudentId() {
        return studentId;
    }

    public void setStudentId(int studentId) {
        this.studentId = studentId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGrade() {
        return grade;
    }

    public void setGrade(String grade) {
        this.grade = grade;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public Timestamp getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Timestamp createdAt) {
        this.createdAt = createdAt;
    }

    public Timestamp getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Timestamp updatedAt) {
        this.updatedAt = updatedAt;
    }
}
```

 `Student` 类设计得非常清晰，封装了学生的相关信息，包括学生 ID、姓名、性别、年龄、年级、专业以及创建和更新时间。以下是一些小的优化方向和扩展功能，帮助提升代码的灵活性和可维护性。

### 1. **构造函数优化**

在数据库操作时，想要创建 `Student` 对象而不需要所有字段的值，可以为 `Student` 类添加一个无参构造函数，并且在必要时提供一个带部分参数的构造函数。

```java
public Student() {
    // 无参构造函数
}

public Student(int studentId, String name, String gender, int age, String grade, String major) {
    this.studentId = studentId;
    this.name = name;
    this.gender = gender;
    this.age = age;
    this.grade = grade;
    this.major = major;
}
```

这种做法允许你在实例化对象时不必完全依赖所有的字段值，特别是在某些情况下，部分字段可能未设置或为默认值。

### 2. **覆盖 `toString()` 方法**

覆盖 `toString()` 方法，可以方便地打印出 `Student` 对象的信息，有助于调试和日志记录。

```java
@Override
public String toString() {
    return "Student{" +
           "studentId=" + studentId +
           ", name='" + name + '\'' +
           ", gender='" + gender + '\'' +
           ", age=" + age +
           ", grade='" + grade + '\'' +
           ", major='" + major + '\'' +
           ", createdAt=" + createdAt +
           ", updatedAt=" + updatedAt +
           '}';
}
```

### 3. **日期和时间处理的优化**

你使用了 `Timestamp` 类型来存储 `createdAt` 和 `updatedAt`，这是完全合理的。但是，在某些情况下，日期和时间的处理可能会更加灵活和方便。你可以考虑将 `Timestamp` 替换为 `LocalDateTime`，这是 Java 8 引入的类，适用于时间处理，且与数据库交互时能够更好地避免时区问题。

```java
import java.time.LocalDateTime;

private LocalDateTime createdAt;
private LocalDateTime updatedAt;

public LocalDateTime getCreatedAt() {
    return createdAt;
}

public void setCreatedAt(LocalDateTime createdAt) {
    this.createdAt = createdAt;
}

public LocalDateTime getUpdatedAt() {
    return updatedAt;
}

public void setUpdatedAt(LocalDateTime updatedAt) {
    this.updatedAt = updatedAt;
}
```

如果你打算将日期存储到数据库中，通常将 `LocalDateTime` 转换为 `Timestamp`，或者直接使用 `LocalDateTime` 进行数据库操作（如果你的数据库支持）。

### 4. **字段验证和约束**

你可以在 `set` 方法中加入一些简单的验证逻辑，确保传入的值符合预期。例如，年龄不能为负值，性别只能是“男”或“女”等。

```java
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("年龄不能为负数");
    }
    this.age = age;
}

public void setGender(String gender) {
    if (!gender.equals("男") && !gender.equals("女")) {
        throw new IllegalArgumentException("性别只能为 '男' 或 '女'");
    }
    this.gender = gender;
}
```

这样可以在对象赋值时增加数据的准确性和安全性。

### 5. **`equals` 和 `hashCode` 方法**

如果你打算使用 `Student` 对象在集合中进行比较（例如在 `HashSet` 或 `HashMap` 中），则需要覆盖 `equals` 和 `hashCode` 方法，以确保对象的比较符合预期。

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Student student = (Student) o;
    return studentId == student.studentId;
}

@Override
public int hashCode() {
    return Objects.hash(studentId);
}
```

这样可以确保 `Student` 对象在集合中的行为符合预期。

### 6. **SQL 转换方法**

如果你打算将 `Student` 对象与数据库中的数据交互，你可以添加一些方便的转换方法，比如将 `Student` 对象转换为 SQL 插入语句的参数列表。

```java
public Object[] toSqlParams() {
    return new Object[] { studentId, name, gender, age, grade, major, createdAt, updatedAt };
}
```

这种方法可以简化在数据库操作中的 `PreparedStatement` 的设置。

### 完整优化后的代码示例：

```java
import java.sql.*;
import java.time.LocalDateTime;
import java.util.Objects;

public class Student {
    private int studentId;
    private String name;
    private String gender;
    private int age;
    private String grade;
    private String major;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // 构造方法
    public Student(int studentId, String name, String gender, int age, String grade, String major, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.studentId = studentId;
        this.name = name;
        this.gender = gender;
        this.age = age;
        this.grade = grade;
        this.major = major;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    public Student() {
    }

    // Getter 和 Setter 方法
    public int getStudentId() {
        return studentId;
    }

    public void setStudentId(int studentId) {
        this.studentId = studentId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        if (!gender.equals("男") && !gender.equals("女")) {
            throw new IllegalArgumentException("性别只能为 '男' 或 '女'");
        }
        this.gender = gender;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("年龄不能为负数");
        }
        this.age = age;
    }

    public String getGrade() {
        return grade;
    }

    public void setGrade(String grade) {
        this.grade = grade;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    // 重写 toString 方法
    @Override
    public String toString() {
        return "Student{" +
               "studentId=" + studentId +
               ", name='" + name + '\'' +
               ", gender='" + gender + '\'' +
               ", age=" + age +
               ", grade='" + grade + '\'' +
               ", major='" + major + '\'' +
               ", createdAt=" + createdAt +
               ", updatedAt=" + updatedAt +
               '}';
    }

    // 重写 equals 和 hashCode 方法
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return studentId == student.studentId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(studentId);
    }

    // 转换为 SQL 参数数组
    public Object[] toSqlParams() {
        return new Object[] { studentId, name, gender, age, grade, major, createdAt, updatedAt };
    }
}
```

### 总结：

- **灵活性**：增加了无参构造函数和部分构造函数，提高了类的灵活性。
- **代码简洁**：覆盖了 `toString()`、`equals()` 和 `hashCode()` 方法，增强了可读性和数据比较能力。
- **验证与安全**：增加了简单的验证逻辑，确保输入数据的有效性。
- **日期时间处理**：推荐使用 `LocalDateTime` 替代 `Timestamp`，增强对日期时间的处理能力。

这些优化可以提升类的功能性、健壮性以及与数据库的交互能力。







## User 类

```java
package model;

public class User {
    private int id;
    private String name;
    private String username;
    private String password;
    private int role;

    // 构造函数
    public User(int id, String name, String username, String password, int role) {
        this.id = id;
        this.name = name;
        this.username = username;
        this.password = password;
        this.role = role;
    }

    // Getter 和 Setter 方法
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public int getRole() {
        return role;
    }

    public void setRole(int role) {
        this.role = role;
    }
}

```

`User` 类设计得很好，封装了用户的基本信息，包括 ID、姓名、用户名、密码和角色。为了提高代码的可维护性和安全性，以下是一些优化和扩展建议：

### 1. **封装密码字段**

为了提高系统的安全性，可以考虑在设置和获取密码时进行加密处理，避免直接存储明文密码。常见的做法是使用哈希算法（如 `SHA-256` 或 `bcrypt`）对密码进行加密存储。你可以在 `setPassword()` 方法中进行加密，获取密码时则不需要暴露明文。

例如，使用 `BCrypt` 来加密密码：

```java
import org.mindrot.jbcrypt.BCrypt;

public class User {
    private int id;
    private String name;
    private String username;
    private String password;  // 存储加密后的密码
    private int role;

    // 构造函数
    public User(int id, String name, String username, String password, int role) {
        this.id = id;
        this.name = name;
        this.username = username;
        this.password = BCrypt.hashpw(password, BCrypt.gensalt());
        this.role = role;
    }

    // Getter 和 Setter 方法
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = BCrypt.hashpw(password, BCrypt.gensalt());
    }

    // 验证密码是否正确
    public boolean checkPassword(String password) {
        return BCrypt.checkpw(password, this.password);
    }

    public int getRole() {
        return role;
    }

    public void setRole(int role) {
        this.role = role;
    }
}
```

### 2. **增加 `toString()` 方法**

为了方便调试和日志记录，推荐覆盖 `toString()` 方法，提供 `User` 对象的字符串表示，方便输出用户信息。

```java
@Override
public String toString() {
    return "User{" +
           "id=" + id +
           ", name='" + name + '\'' +
           ", username='" + username + '\'' +
           ", role=" + role +
           '}';
}
```

### 3. **增加 `equals` 和 `hashCode` 方法**

如果你在集合中使用 `User` 类（例如 `HashSet` 或 `HashMap`），最好覆盖 `equals()` 和 `hashCode()` 方法，以确保对象的比较行为是预期的。

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    User user = (User) o;
    return id == user.id;
}

@Override
public int hashCode() {
    return Objects.hash(id);
}
```

### 4. **字段验证**

为了避免无效数据的设置，可以对一些字段添加验证逻辑。例如，验证用户名不为空，密码长度足够等。

```java
public void setUsername(String username) {
    if (username == null || username.trim().isEmpty()) {
        throw new IllegalArgumentException("用户名不能为空");
    }
    this.username = username;
}

public void setPassword(String password) {
    if (password == null || password.length() < 6) {
        throw new IllegalArgumentException("密码长度必须大于6");
    }
    this.password = BCrypt.hashpw(password, BCrypt.gensalt());
}
```

### 5. **添加角色的枚举类型（可选）**

如果系统有多个角色，可以考虑使用枚举来定义角色，而不是直接使用 `int` 类型。例如：

```java
public enum Role {
    ADMIN(1),
    USER(2);

    private final int roleId;

    Role(int roleId) {
        this.roleId = roleId;
    }

    public int getRoleId() {
        return roleId;
    }

    public static Role fromInt(int roleId) {
        for (Role role : Role.values()) {
            if (role.getRoleId() == roleId) {
                return role;
            }
        }
        throw new IllegalArgumentException("无效的角色ID");
    }
}
```

然后，你可以在 `User` 类中使用 `Role` 枚举类型来替代 `int role`：

```java
private Role role;

public Role getRole() {
    return role;
}

public void setRole(Role role) {
    this.role = role;
}

public void setRole(int roleId) {
    this.role = Role.fromInt(roleId);
}
```

### 完整优化后的 `User` 类：

```java
import org.mindrot.jbcrypt.BCrypt;
import java.util.Objects;

public class User {
    private int id;
    private String name;
    private String username;
    private String password;  // 存储加密后的密码
    private Role role;

    // 构造函数
    public User(int id, String name, String username, String password, Role role) {
        this.id = id;
        this.name = name;
        this.username = username;
        this.password = BCrypt.hashpw(password, BCrypt.gensalt());
        this.role = role;
    }

    // Getter 和 Setter 方法
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            throw new IllegalArgumentException("用户名不能为空");
        }
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        if (password == null || password.length() < 6) {
            throw new IllegalArgumentException("密码长度必须大于6");
        }
        this.password = BCrypt.hashpw(password, BCrypt.gensalt());
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    // 验证密码是否正确
    public boolean checkPassword(String password) {
        return BCrypt.checkpw(password, this.password);
    }

    @Override
    public String toString() {
        return "User{" +
               "id=" + id +
               ", name='" + name + '\'' +
               ", username='" + username + '\'' +
               ", role=" + role +
               '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return id == user.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    // 角色枚举
    public enum Role {
        ADMIN(1),
        USER(2);

        private final int roleId;

        Role(int roleId) {
            this.roleId = roleId;
        }

        public int getRoleId() {
            return roleId;
        }

        public static Role fromInt(int roleId) {
            for (Role role : Role.values()) {
                if (role.getRoleId() == roleId) {
                    return role;
                }
            }
            throw new IllegalArgumentException("无效的角色ID");
        }
    }
}
```

### 总结：

1. **安全性增强**：通过加密存储密码，增加了用户数据的安全性。
2. **字段验证**：增加了字段验证逻辑，确保输入数据的有效性。
3. **增强可读性和可维护性**：通过覆盖 `toString()`、`equals()` 和 `hashCode()`，提升了类的可读性和可维护性。
4. **角色枚举**：使用枚举表示角色，可以提高代码的可读性和可扩展性。

这样设计后的 `User` 类在功能上更加完备，适用于更复杂的应用场景。

#程序入口

```java
package main;

//import controller.BindView;
//import controller.StudentController;
import view.Login;
//import view.StudentManagerView;

public class Main {
    public static void main(String[] args) {
    	new Login().setVisible(true);
    }
}
```

在你的 `Main` 类中，目前你通过 `new Login().setVisible(true);` 启动了登录界面的可见性，这看起来是一个非常基础的启动方式。为了使系统更加清晰和易于维护，可以考虑以下几点改进：

### 1. **使用控制器进行初始化**

目前你直接在 `Main` 类中实例化了 `Login` 视图。如果将控制器引入 `Main` 类，控制器可以在视图初始化时处理相应的逻辑，例如与数据库交互、视图更新等。你可以创建一个控制器类来处理业务逻辑和视图之间的交互。

### 2. **引入视图和控制器的分离**

理想情况下，`Main` 类应仅负责启动应用程序，而不直接管理具体的视图显示。你可以创建一个 `Controller` 类来协调视图和业务逻辑。

### 3. **简化视图的创建**

`Login` 视图的创建可以通过控制器来管理，控制器负责初始化视图并处理相应的事件（如登录验证等）。

### 改进后的代码：

#### 1. **创建 `Main` 类**

```java
package main;

import controller.LoginController;
import view.Login;

public class Main {
    public static void main(String[] args) {
        // 创建登录控制器，并将登录视图传递给它
        LoginController loginController = new LoginController(new Login());
        loginController.showLoginView();
    }
}
```

#### 2. **创建 `LoginController` 类**

`LoginController` 类负责初始化视图和处理登录逻辑。

```java
package controller;

import view.Login;

public class LoginController {
    private Login loginView;

    // 构造函数，传递 Login 视图对象
    public LoginController(Login loginView) {
        this.loginView = loginView;
    }

    // 显示登录视图
    public void showLoginView() {
        loginView.setVisible(true);
    }

    // 在这里可以处理登录逻辑，例如验证用户名、密码等
    public void handleLogin(String username, String password) {
        // 假设用户名和密码的验证逻辑已经在此处处理
        // 根据需要与数据库或其他逻辑交互
        if (isValidLogin(username, password)) {
            // 登录成功，跳转到主界面或其他操作
        } else {
            // 登录失败，提示错误
        }
    }

    // 登录验证方法（示例）
    private boolean isValidLogin(String username, String password) {
        // 在这里加入验证逻辑，例如与数据库比对
        return "admin".equals(username) && "1234".equals(password);  // 示例条件
    }
}
```

#### 3. **修改 `Login` 视图**

`Login` 视图只负责显示界面，并通过控制器与后端逻辑进行交互。你可以通过控制器将事件处理绑定到界面组件。

```java
package view;

import javax.swing.*;
import controller.LoginController;

public class Login extends JFrame {
    private JTextField usernameField;
    private JPasswordField passwordField;
    private JButton loginButton;
    private LoginController loginController;

    public Login() {
        // 设置视图的基础属性
        setTitle("登录");
        setSize(300, 200);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        // 初始化组件
        usernameField = new JTextField(15);
        passwordField = new JPasswordField(15);
        loginButton = new JButton("登录");

        // 布局
        setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
        add(new JLabel("用户名"));
        add(usernameField);
        add(new JLabel("密码"));
        add(passwordField);
        add(loginButton);

        // 初始化控制器
        loginController = new LoginController(this);

        // 绑定按钮事件
        loginButton.addActionListener(e -> handleLoginAction());
    }

    // 处理登录按钮点击事件
    private void handleLoginAction() {
        String username = usernameField.getText();
        String password = new String(passwordField.getPassword());
        loginController.handleLogin(username, password);
    }
}
```

**主要变化：**

1. **视图与控制器分离**：`Main` 类负责启动应用程序，`LoginController` 负责登录逻辑，`Login` 只负责界面显示。
2. **控制器的引入**：`LoginController` 处理视图和模型之间的交互，比如登录验证。
3. **登录逻辑**：登录验证的逻辑通过 `LoginController` 完成，并通过 `Login` 视图获取输入数据。

**优点：**

- **可维护性**：随着项目的扩展，视图和控制器的职责更清晰，便于维护。
- **可扩展性**：登录视图和控制器分离后，可以轻松地替换视图或修改业务逻辑而不影响其他部分。
- **模块化**：各部分职责分明，符合 `MVC` 设计模式。

这种结构为后期添加更多功能（如注册、主界面、数据库操作等）奠定了良好的基础。